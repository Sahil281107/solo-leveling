solo-leveling-backend/
prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  user_id                                                                        Int                           @id @default(autoincrement())
  email                                                                          String                        @unique(map: "email") @db.VarChar(255)
  username                                                                       String                        @unique(map: "username") @db.VarChar(100)
  password_hash                                                                  String                        @db.VarChar(255)
  user_type                                                                      UserType
  profile_photo_url                                                              String?                       @db.VarChar(500)
  created_at                                                                     DateTime?                     @default(now()) @db.Timestamp(0)
  last_login                                                                     DateTime?                     @db.Timestamp(0)
  is_active                                                                      Boolean?                      @default(true)
  email_verified                                                                 Boolean?                      @default(false)
  verification_token                                                             String?                       @db.VarChar(255)
  reset_password_token                                                           String?                       @db.VarChar(255)
  reset_password_expires                                                         DateTime?                     @db.Timestamp(0)
  activity_logs                                                                  activity_logs[]
  adminProfile                                                                   AdminProfile?
  adventurerProfile                                                              AdventurerProfile?
  coach_feedback_coach_feedback_coach_user_idTousers                             coach_feedback[]              @relation("coach_feedback_coach_user_idTousers")
  coach_feedback_coach_feedback_student_user_idTousers                           coach_feedback[]              @relation("coach_feedback_student_user_idTousers")
  coachProfile                                                                   CoachProfile?
  coach_student_relationships_coach_student_relationships_coach_user_idTousers   coach_student_relationships[] @relation("coach_student_relationships_coach_user_idTousers")
  coach_student_relationships_coach_student_relationships_student_user_idTousers coach_student_relationships[] @relation("coach_student_relationships_student_user_idTousers")
  daily_checkins                                                                 daily_checkins[]
  level_progression                                                              level_progression[]
  media_uploads                                                                  media_uploads[]
  notifications                                                                  notifications[]
  quest_completion_history_quest_completion_history_user_idTousers               quest_completion_history[]    @relation("quest_completion_history_user_idTousers")
  quest_completion_history_quest_completion_history_coach_user_idTousers         quest_completion_history[]    @relation("quest_completion_history_coach_user_idTousers")
  user_achievements                                                              user_achievements[]
  user_active_quests                                                             user_active_quests[]
  user_custom_quests                                                             user_custom_quests[]
  user_sessions                                                                  user_sessions[]
  user_stats                                 
  admin_ip_whitelist_created    AdminIpWhitelist[]
  feature_flags_created         FeatureFlag[]
  performance_logs              PerformanceLog[]
  user_analytics                UserAnalytics[]
  system_error_logs_user        SystemErrorLog[] @relation("SystemErrorLogUser")
  system_error_logs_resolver    SystemErrorLog[] @relation("SystemErrorLogResolver")                                    user_stats[]

  @@index([email], map: "idx_email")
  @@index([user_type], map: "idx_user_type")
  @@index([username], map: "idx_username")
  @@map("users")
}

model AdminProfile {
  admin_profile_id Int               @id @default(autoincrement())
  user_id          Int               @unique(map: "user_id")
  full_name        String            @db.VarChar(255)
  department       String?           @default("System Administration") @db.VarChar(100)
  access_level     AdminAccessLevel? @default(MODERATOR)
  permissions      Json?
  last_action      String?           @db.VarChar(255)
  last_action_date DateTime?         @db.Timestamp(0)
  created_at       DateTime?         @default(now()) @db.Timestamp(0)
  updated_at       DateTime?         @default(now()) @updatedAt @db.Timestamp(0)
  user             User              @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "admin_profiles_ibfk_1")

  @@index([user_id], map: "idx_user_id")
  @@map("admin_profiles")
}

model AdventurerProfile {
  profile_id               Int             @id @default(autoincrement())
  user_id                  Int             @unique(map: "user_id")
  full_name                String          @db.VarChar(255)
  field_of_interest        String          @db.VarChar(100)
  custom_goal              String?         @db.Text
  commitment_level         CommitmentLevel
  experience_level         ExperienceLevel
  current_level            Int?            @default(1)
  total_exp                Int?            @default(0)
  current_exp              Int?            @default(0)
  exp_to_next_level        Int?            @default(100)
  streak_days              Int?            @default(0)
  longest_streak           Int?            @default(0)
  last_activity_date       DateTime?       @db.Date
  title                    String?         @default("Novice Adventurer") @db.VarChar(255)
  timezone                 String?         @default("UTC") @db.VarChar(50)
  notification_preferences Json?
  created_at               DateTime?       @default(now()) @db.Timestamp(0)
  updated_at               DateTime?       @default(now()) @updatedAt @db.Timestamp(0)
  user                     User            @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "adventurer_profiles_ibfk_1")

  @@index([streak_days, last_activity_date], map: "idx_adventurer_profiles_streak")
  @@index([field_of_interest], map: "idx_field_of_interest")
  @@index([current_level], map: "idx_level")
  @@map("adventurer_profiles")
}

model CoachProfile {
  coach_profile_id       Int                 @id @default(autoincrement())
  user_id                Int                 @unique(map: "user_id")
  full_name              String              @db.VarChar(255)
  specialization         String?             @db.VarChar(100)
  bio                    String?             @db.Text
  credentials            String?             @db.Text
  years_experience       Int?
  max_students           Int?                @default(10)
  current_students       Int?                @default(0)
  verification_status    VerificationStatus? @default(pending)
  created_at             DateTime?           @default(now()) @db.Timestamp(0)
  updated_at             DateTime?           @default(now()) @updatedAt @db.Timestamp(0)
  total_students_coached Int?                @default(0)
  success_stories        Int?                @default(0)
  certification          String?             @db.VarChar(255)
  user                   User                @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "coach_profiles_ibfk_1")

  @@index([specialization], map: "idx_specialization")
  @@map("coach_profiles")
}

model AdminActionLog {
  log_id         Int       @id @default(autoincrement())
  admin_user_id  Int
  action_type    String    @db.VarChar(100)
  target_type    String?   @db.VarChar(50)
  target_id      Int?
  action_details Json?
  ip_address     String?   @db.VarChar(45)
  user_agent     String?   @db.Text
  created_at     DateTime? @default(now()) @db.Timestamp(0)

  @@index([action_type], map: "idx_action_type")
  @@index([admin_user_id], map: "idx_admin_user")
  @@index([created_at], map: "idx_created")
  @@map("admin_action_logs")
}

model achievements {
  achievement_id          Int                           @id @default(autoincrement())
  achievement_name        String                        @db.VarChar(255)
  achievement_description String?                       @db.Text
  achievement_icon        String?                       @db.VarChar(10)
  achievement_type        achievements_achievement_type
  requirement_value       Int?
  xp_reward               Int?                          @default(0)
  is_active               Boolean?                      @default(true)
  user_achievements       user_achievements[]
}

model activity_logs {
  log_id           Int                         @id @default(autoincrement())
  user_id          Int
  activity_type    activity_logs_activity_type
  activity_details Json?
  ip_address       String?                     @db.VarChar(45)
  user_agent       String?                     @db.Text
  created_at       DateTime?                   @default(now()) @db.Timestamp(0)
  users            User                        @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "activity_logs_ibfk_1")

  @@index([ip_address, created_at], map: "idx_activity_logs_ip")
  @@index([activity_type, created_at, user_id], map: "idx_activity_logs_login")
  @@index([created_at], map: "idx_created")
  @@index([activity_type], map: "idx_type")
  @@index([user_id], map: "idx_user")
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
model coach_feedback {
  feedback_id                                 Int                          @id @default(autoincrement())
  coach_user_id                               Int
  student_user_id                             Int
  feedback_type                               coach_feedback_feedback_type
  related_quest_id                            Int?
  feedback_text                               String                       @db.Text
  rating                                      Int?
  is_read                                     Boolean?                     @default(false)
  created_at                                  DateTime?                    @default(now()) @db.Timestamp(0)
  users_coach_feedback_coach_user_idTousers   User                         @relation("coach_feedback_coach_user_idTousers", fields: [coach_user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "coach_feedback_ibfk_1")
  users_coach_feedback_student_user_idTousers User                         @relation("coach_feedback_student_user_idTousers", fields: [student_user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "coach_feedback_ibfk_2")
  quest_completion_history                    quest_completion_history?    @relation(fields: [related_quest_id], references: [completion_id], onUpdate: NoAction, map: "coach_feedback_ibfk_3")

  @@index([coach_user_id], map: "idx_coach")
  @@index([created_at], map: "idx_created")
  @@index([student_user_id], map: "idx_student")
  @@index([related_quest_id], map: "related_quest_id")
}

model coach_student_relationships {
  relationship_id                                          Int                                            @id @default(autoincrement())
  coach_user_id                                            Int
  student_user_id                                          Int
  status                                                   coach_student_relationships_status?            @default(pending)
  relationship_type                                        coach_student_relationships_relationship_type? @default(primary)
  started_at                                               DateTime?                                      @default(now()) @db.Timestamp(0)
  ended_at                                                 DateTime?                                      @db.Timestamp(0)
  notes                                                    String?                                        @db.Text
  created_at                                               DateTime?                                      @default(now()) @db.Timestamp(0)
  updated_at                                               DateTime?                                      @default(now()) @db.Timestamp(0)
  users_coach_student_relationships_coach_user_idTousers   User                                           @relation("coach_student_relationships_coach_user_idTousers", fields: [coach_user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "coach_student_relationships_ibfk_1")
  users_coach_student_relationships_student_user_idTousers User                                           @relation("coach_student_relationships_student_user_idTousers", fields: [student_user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "coach_student_relationships_ibfk_2")

  @@unique([coach_user_id, student_user_id], map: "unique_coach_student")
  @@index([coach_user_id], map: "idx_coach")
  @@index([status], map: "idx_status")
  @@index([student_user_id], map: "idx_student")
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
model daily_checkins {
  checkin_id       Int       @id @default(autoincrement())
  user_id          Int
  checkin_date     DateTime  @db.Date
  quests_completed Int?      @default(0)
  total_xp_earned  Int?      @default(0)
  mood_rating      Int?
  energy_level     Int?
  notes            String?   @db.Text
  created_at       DateTime? @default(now()) @db.Timestamp(0)
  users            User      @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "daily_checkins_ibfk_1")

  @@unique([user_id, checkin_date], map: "unique_user_date")
  @@index([user_id, checkin_date(sort: Desc)], map: "idx_checkin_streak")
  @@index([user_id, checkin_date], map: "idx_daily_checkin_user_date")
  @@index([user_id, checkin_date], map: "idx_daily_checkins_user_date")
  @@index([checkin_date], map: "idx_date")
  @@index([user_id], map: "idx_user")
}

model fields_of_interest {
  field_id          Int               @id @default(autoincrement())
  field_name        String            @unique(map: "field_name") @db.VarChar(100)
  field_icon        String?           @db.VarChar(10)
  field_description String?           @db.Text
  is_active         Boolean?          @default(true)
  created_at        DateTime?         @default(now()) @db.Timestamp(0)
  quest_templates   quest_templates[]
  stats_template    stats_template[]
}

model level_progression {
  progression_id       Int       @id @default(autoincrement())
  user_id              Int
  old_level            Int
  new_level            Int
  total_exp_at_levelup Int
  achieved_at          DateTime? @default(now()) @db.Timestamp(0)
  milestone_name       String?   @db.VarChar(255)
  users                User      @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "level_progression_ibfk_1")

  @@index([achieved_at], map: "idx_achieved_at")
  @@index([user_id], map: "idx_user")
}

model media_uploads {
  media_id    Int                      @id @default(autoincrement())
  user_id     Int
  media_type  media_uploads_media_type
  file_url    String                   @db.VarChar(500)
  file_name   String?                  @db.VarChar(255)
  file_size   Int?
  mime_type   String?                  @db.VarChar(100)
  uploaded_at DateTime?                @default(now()) @db.Timestamp(0)
  users       User                     @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "media_uploads_ibfk_1")

  @@index([media_type], map: "idx_type")
  @@index([user_id], map: "idx_user")
}

model notifications {
  notification_id   Int                             @id @default(autoincrement())
  user_id           Int
  notification_type notifications_notification_type
  title             String                          @db.VarChar(255)
  message           String                          @db.Text
  is_read           Boolean?                        @default(false)
  action_url        String?                         @db.VarChar(500)
  created_at        DateTime?                       @default(now()) @db.Timestamp(0)
  expires_at        DateTime?                       @db.Timestamp(0)
  users             User                            @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "notifications_ibfk_1")

  @@index([created_at], map: "idx_created")
  @@index([user_id, is_read], map: "idx_user_unread")
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
model quest_completion_history {
  completion_id                                       Int                                           @id @default(autoincrement())
  user_id                                             Int
  quest_template_id                                   Int?
  quest_type                                          String                                        @db.VarChar(20)
  completed_at                                        DateTime?                                     @default(now()) @db.Timestamp(0)
  xp_earned                                           Int
  time_to_complete                                    Int?
  difficulty_rating                                   Int?
  notes                                               String?                                       @db.Text
  verified_by_coach                                   Boolean?                                      @default(false)
  coach_user_id                                       Int?
  verification_method                                 quest_completion_history_verification_method? @default(manual)
  proof_url                                           String?                                       @db.VarChar(500)
  coach_feedback                                      coach_feedback[]
  users_quest_completion_history_user_idTousers       User                                          @relation("quest_completion_history_user_idTousers", fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "quest_completion_history_ibfk_1")
  quest_templates                                     quest_templates?                              @relation(fields: [quest_template_id], references: [quest_template_id], onUpdate: NoAction, map: "quest_completion_history_ibfk_2")
  users_quest_completion_history_coach_user_idTousers User?                                         @relation("quest_completion_history_coach_user_idTousers", fields: [coach_user_id], references: [user_id], onUpdate: NoAction, map: "quest_completion_history_ibfk_3")

  @@index([coach_user_id, verified_by_coach], map: "idx_coach_verification")
  @@index([completed_at], map: "idx_completed_at")
  @@index([user_id, completed_at], map: "idx_quest_completion_date")
  @@index([user_id, completed_at], map: "idx_quest_completion_user_date")
  @@index([user_id], map: "idx_user")
  @@index([quest_template_id], map: "quest_template_id")
}

model quest_templates {
  quest_template_id        Int                        @id @default(autoincrement())
  field_name               String                     @db.VarChar(100)
  quest_type               quest_templates_quest_type
  quest_title              String                     @db.VarChar(255)
  quest_description        String?                    @db.Text
  base_xp                  Int
  difficulty               quest_templates_difficulty
  related_stat             String?                    @db.VarChar(100)
  stat_increase            Int?                       @default(1)
  is_active                Boolean?                   @default(true)
  created_at               DateTime?                  @default(now()) @db.Timestamp(0)
  quest_completion_history quest_completion_history[]
  fields_of_interest       fields_of_interest         @relation(fields: [field_name], references: [field_name], onDelete: Cascade, onUpdate: NoAction, map: "quest_templates_ibfk_1")
  user_active_quests       user_active_quests[]

  @@index([field_name, quest_type], map: "idx_field_type")
  @@index([related_stat], map: "idx_related_stat")
}

model stats_template {
  stat_template_id   Int                @id @default(autoincrement())
  field_name         String             @db.VarChar(100)
  stat_name          String             @db.VarChar(100)
  stat_icon          String?            @db.VarChar(10)
  max_value          Int?               @default(100)
  initial_value      Int?               @default(10)
  stat_order         Int?               @default(0)
  fields_of_interest fields_of_interest @relation(fields: [field_name], references: [field_name], onDelete: Cascade, onUpdate: NoAction, map: "stats_template_ibfk_1")

  @@unique([field_name, stat_name], map: "unique_field_stat")
  @@index([field_name], map: "idx_field")
}

model system_settings {
  setting_id    Int                           @id @default(autoincrement())
  setting_key   String                        @unique(map: "setting_key") @db.VarChar(100)
  setting_value String?                       @db.Text
  setting_type  system_settings_setting_type? @default(string)
  description   String?                       @db.Text
  updated_at    DateTime?                     @default(now()) @db.Timestamp(0)
}

model user_achievements {
  user_achievement_id Int          @id @default(autoincrement())
  user_id             Int
  achievement_id      Int
  earned_at           DateTime?    @default(now()) @db.Timestamp(0)
  users               User         @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "user_achievements_ibfk_1")
  achievements        achievements @relation(fields: [achievement_id], references: [achievement_id], onDelete: Cascade, onUpdate: NoAction, map: "user_achievements_ibfk_2")

  @@unique([user_id, achievement_id], map: "unique_user_achievement")
  @@index([achievement_id], map: "achievement_id")
  @@index([user_id], map: "idx_user")
}

model user_active_quests {
  active_quest_id   Int                           @id @default(autoincrement())
  user_id           Int
  quest_template_id Int
  quest_type        user_active_quests_quest_type
  assigned_date     DateTime                      @db.Date
  expires_at        DateTime                      @db.Timestamp(0)
  is_completed      Boolean?                      @default(false)
  completed_at      DateTime?                     @db.Timestamp(0)
  xp_earned         Int?
  created_at        DateTime?                     @default(now()) @db.Timestamp(0)
  users             User                          @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "user_active_quests_ibfk_1")
  quest_templates   quest_templates               @relation(fields: [quest_template_id], references: [quest_template_id], onDelete: Cascade, onUpdate: NoAction, map: "user_active_quests_ibfk_2")

  @@index([user_id, is_completed], map: "idx_active_quests_user")
  @@index([expires_at], map: "idx_expires")
  @@index([user_id, quest_type, expires_at], map: "idx_quest_user_type_expires")
  @@index([user_id, assigned_date], map: "idx_user_date")
  @@index([user_id, quest_type], map: "idx_user_type")
  @@index([quest_template_id], map: "quest_template_id")
}

model user_custom_quests {
  custom_quest_id   Int                           @id @default(autoincrement())
  user_id           Int
  quest_title       String                        @db.VarChar(255)
  quest_description String?                       @db.Text
  target_xp         Int                           @default(25)
  difficulty        user_custom_quests_difficulty @default(medium)
  related_stat      String?                       @db.VarChar(100)
  is_active         Boolean?                      @default(true)
  created_at        DateTime?                     @default(now()) @db.Timestamp(0)
  updated_at        DateTime?                     @default(now()) @db.Timestamp(0)
  users             User                          @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "user_custom_quests_ibfk_1")

  @@index([user_id, is_active], map: "idx_user_active")
}

model user_sessions {
  session_id    String                      @id @db.VarChar(255)
  user_id       Int
  refresh_token String?                     @db.VarChar(500)
  expires_at    DateTime                    @db.Timestamp(0)
  created_at    DateTime?                   @default(now()) @db.Timestamp(0)
  last_activity DateTime?                   @default(now()) @db.Timestamp(0)
  ip_address    String?                     @db.VarChar(45)
  user_agent    String?                     @db.Text
  is_active     Boolean?                    @default(true)
  login_method  user_sessions_login_method? @default(web)
  device_info   String?                     @db.Text
  users         User                        @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "user_sessions_ibfk_1")

  @@index([expires_at], map: "idx_expires")
  @@index([user_id], map: "idx_user")
  @@index([user_id, is_active, expires_at], map: "idx_user_sessions_active")
  @@index([expires_at], map: "idx_user_sessions_expires")
}

model user_stats {
  user_stat_id  Int       @id @default(autoincrement())
  user_id       Int
  stat_name     String    @db.VarChar(100)
  stat_icon     String?   @db.VarChar(10)
  current_value Int?      @default(10)
  max_value     Int?      @default(100)
  last_updated  DateTime? @default(now()) @db.Timestamp(0)
  users         User      @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "user_stats_ibfk_1")

  @@unique([user_id, stat_name], map: "unique_user_stat")
  @@index([user_id], map: "idx_user")
  @@index([user_id], map: "idx_user_stats_user")
}

enum UserType {
  adventurer
  coach
  admin
}

enum AdminAccessLevel {
  SUPER_ADMIN
  ADMIN
  MODERATOR
}

enum CommitmentLevel {
  thirty_minutes   @map("30_minutes")
  one_hour         @map("1_hour")
  two_hours        @map("2_hours")
  three_plus_hours @map("3_plus_hours")
}

enum ExperienceLevel {
  beginner
  some_experience
  intermediate
  advanced
}

enum VerificationStatus {
  pending
  verified
  rejected
}

enum activity_logs_activity_type {
  login
  quest_complete
  level_up
  stat_increase
  achievement_earned
  profile_update
}

enum media_uploads_media_type {
  profile_photo
  quest_proof
  achievement_badge
}

enum notifications_notification_type {
  quest_reminder
  level_up
  achievement
  coach_feedback
  streak_warning
  system
}

enum quest_templates_quest_type {
  daily
  weekly
  special
  main
}

enum coach_feedback_feedback_type {
  daily
  weekly
  quest
  general
  guidance
}

enum coach_student_relationships_status {
  pending
  active
  terminated
}

enum system_settings_setting_type {
  string
  number
  boolean
  json
}

enum user_active_quests_quest_type {
  daily
  weekly
  special
  main
}

enum achievements_achievement_type {
  streak
  level
  quest
  stat
  special
}

enum coach_student_relationships_relationship_type {
  primary
  secondary
  observer
}

enum user_custom_quests_difficulty {
  easy
  medium
  hard
}

enum quest_templates_difficulty {
  easy
  medium
  hard
}

enum user_sessions_login_method {
  web
  mobile
  api
}

enum quest_completion_history_verification_method {
  manual
  photo
  video
  gps
  app_integration
}
model AdminIpWhitelist {
  whitelist_id Int       @id @default(autoincrement())
  ip_address   String    @db.VarChar(45)
  ip_range     String?   @db.VarChar(18)
  description  String?   @db.VarChar(255)
  created_by   Int?
  created_at   DateTime? @default(now()) @db.Timestamp(0)
  is_active    Boolean?  @default(true)
  creator      User?     @relation(fields: [created_by], references: [user_id], onDelete: SetNull)

  @@index([ip_address], map: "idx_ip")
  @@index([is_active], map: "idx_active")
  @@map("admin_ip_whitelist")
}

model FeatureFlag {
  flag_id             Int       @id @default(autoincrement())
  flag_key            String    @unique @db.VarChar(100)
  flag_name           String    @db.VarChar(255)
  description         String?   @db.Text
  is_enabled          Boolean?  @default(false)
  rollout_percentage  Int?      @default(0)
  target_user_types   Json?
  conditions          Json?
  created_by          Int?
  created_at          DateTime? @default(now()) @db.Timestamp(0)
  updated_at          DateTime? @default(now()) @updatedAt @db.Timestamp(0)
  creator             User?     @relation(fields: [created_by], references: [user_id], onDelete: SetNull)

  @@index([flag_key], map: "idx_key")
  @@index([is_enabled], map: "idx_enabled")
  @@map("feature_flags")
}

model PerformanceLog {
  log_id           Int       @id @default(autoincrement())
  endpoint         String    @db.VarChar(255)
  method           String    @db.VarChar(10)
  response_time_ms Int
  status_code      Int
  user_id          Int?
  ip_address       String?   @db.VarChar(45)
  user_agent       String?   @db.Text
  created_at       DateTime? @default(now()) @db.Timestamp(0)
  user             User?     @relation(fields: [user_id], references: [user_id], onDelete: SetNull)

  @@index([endpoint], map: "idx_endpoint")
  @@index([response_time_ms], map: "idx_response_time")
  @@index([created_at], map: "idx_created")
  @@map("performance_logs")
}

model UserAnalytics {
  analytics_id Int       @id @default(autoincrement())
  user_id      Int?
  session_id   String?   @db.VarChar(255)
  event_type   String    @db.VarChar(50)
  event_data   Json?
  page_url     String?   @db.VarChar(500)
  referrer     String?   @db.VarChar(500)
  device_info  Json?
  ip_address   String?   @db.VarChar(45)
  created_at   DateTime? @default(now()) @db.Timestamp(0)
  user         User?     @relation(fields: [user_id], references: [user_id], onDelete: SetNull)

  @@index([user_id], map: "idx_user")
  @@index([event_type], map: "idx_event_type")
  @@index([session_id], map: "idx_session")
  @@index([created_at], map: "idx_created")
  @@map("user_analytics")
}

model SystemErrorLog {
  error_id      Int       @id @default(autoincrement())
  error_level   String    @db.VarChar(20)
  error_message String    @db.Text
  error_stack   String?   @db.Text
  endpoint      String?   @db.VarChar(255)
  method        String?   @db.VarChar(10)
  user_id       Int?
  request_data  Json?
  ip_address    String?   @db.VarChar(45)
  user_agent    String?   @db.Text
  resolved      Boolean?  @default(false)
  resolved_by   Int?
  resolved_at   DateTime? @db.Timestamp(0)
  created_at    DateTime? @default(now()) @db.Timestamp(0)
  user          User?     @relation("SystemErrorLogUser", fields: [user_id], references: [user_id], onDelete: SetNull)
  resolver      User?     @relation("SystemErrorLogResolver", fields: [resolved_by], references: [user_id], onDelete: SetNull)

  @@index([error_level], map: "idx_level")
  @@index([resolved], map: "idx_resolved")
  @@index([created_at], map: "idx_created")
  @@map("system_error_logs")
}





src/config/database.ts
const mysql = require('mysql2/promise');
require('dotenv').config();

const pool = mysql.createPool({
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '3306'),
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || 'solo_leveling_system',
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

export const testConnection = async () => {
  try {
    const connection = await pool.getConnection();
    console.log('✅ Database connected successfully');
    connection.release();
    return true;
  } catch (error: any) {
    console.error('❌ Database connection failed:', error.message);
    return false;
  }
};

export default pool;




src/config/prisma.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
});

export default prisma;




src/controller/adminController.ts
import { Request, Response } from 'express';
import prisma from '../config/prisma';
import  pool from '../config/database'; // For non-Prisma operations if needed

// Get dashboard statistics
export const getDashboardStats = async (req: Request, res: Response) => {
  try {
    const [
      totalUsers,
      adventurerCount,
      coachCount,
      adminCount,
      activeUsers,
      recentRegistrations
    ] = await Promise.all([
      prisma.user.count(),
      prisma.user.count({ where: { user_type: 'adventurer' } }),
      prisma.user.count({ where: { user_type: 'coach' } }),
      prisma.user.count({ where: { user_type: 'admin' } }),
      prisma.user.count({ where: { is_active: true } }),
      prisma.user.findMany({
        where: {
          created_at: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
          }
        },
        select: {
          user_id: true,
          username: true,
          email: true,
          user_type: true,
          created_at: true
        },
        orderBy: { created_at: 'desc' },
        take: 10
      })
    ]);

    // FIXED: Get total quests count using MySQL pool instead of Prisma
    let totalQuests = 0;
    try {
      const connection = await pool.getConnection();
      
      // Try multiple quest-related tables
      try {
        // First try active_quests (current quests)
        const [activeQuestsResult]: any = await connection.execute(
          'SELECT COUNT(*) as count FROM active_quests'
        );
        const activeQuests = activeQuestsResult[0]?.count || 0;
        
        // Then try quest_completion_history (completed quests)
        const [completedQuestsResult]: any = await connection.execute(
          'SELECT COUNT(*) as count FROM quest_completion_history'
        );
        const completedQuests = completedQuestsResult[0]?.count || 0;
        
        // Total quests = active + completed
        totalQuests = activeQuests + completedQuests;
        
        console.log(`✅ Quest Stats: ${activeQuests} active, ${completedQuests} completed, ${totalQuests} total`);
        
      } catch (questError: any) {
        console.warn('⚠️ Quest tables query failed:', questError.message);
        
        // Fallback: Try to count from quest_templates (templates available)
        try {
          const [templatesResult]: any = await connection.execute(
            'SELECT COUNT(*) as count FROM quest_templates'
          );
          totalQuests = templatesResult[0]?.count || 0;
          console.log(`✅ Using quest templates count: ${totalQuests}`);
        } catch (templateError) {
          console.warn('⚠️ No quest data available, returning 0');
          totalQuests = 0;
        }
      }
      
      connection.release();
      
    } catch (connectionError) {
      console.error('❌ Database connection error for quests:', connectionError);
      totalQuests = 0;
    }

    res.json({
      stats: {
        totalUsers,
        usersByType: {
          adventurers: adventurerCount,
          coaches: coachCount,
          admins: adminCount
        },
        activeUsers,
        totalQuests, // This should now show real data!
        recentRegistrations
      }
    });
  } catch (error) {
    console.error('Get dashboard stats error:', error);
    res.status(500).json({ error: 'Failed to fetch dashboard statistics' });
  }
};

// Get all users with pagination and filters
export const getAllUsers = async (req: Request, res: Response) => {
  try {
    const { 
      page = 1, 
      limit = 10, 
      user_type, 
      search,
      sort_by = 'created_at',
      order = 'desc' 
    } = req.query;

    const skip = (Number(page) - 1) * Number(limit);
    
    const where: any = {};
    
    if (user_type && user_type !== 'all') {
      where.user_type = user_type;
    }
    
    if (search) {
      where.OR = [
        { username: { contains: String(search) } },
        { email: { contains: String(search) } }
      ];
    }

    const [users, total] = await Promise.all([
      prisma.user.findMany({
        where,
        skip,
        take: Number(limit),
        orderBy: { [String(sort_by)]: order },
        select: {
          user_id: true,
          email: true,
          username: true,
          user_type: true,
          profile_photo_url: true,
          created_at: true,
          last_login: true,
          is_active: true,
          email_verified: true,
          adventurerProfile: {
            select: {
              full_name: true,
              current_level: true,
              total_exp: true,
              field_of_interest: true
            }
          },
          coachProfile: {
            select: {
              full_name: true,
              specialization: true,
              current_students: true
            }
          },
          adminProfile: {
            select: {
              full_name: true,
              department: true,
              access_level: true
            }
          }
        }
      }),
      prisma.user.count({ where })
    ]);

    // Log admin action
    await logAdminAction(
      (req as any).user.user_id,
      'VIEW_USERS',
      null,
      null,
      { filters: { user_type, search }, page },
      req
    );

    res.json({
      users,
      pagination: {
        total,
        page: Number(page),
        limit: Number(limit),
        pages: Math.ceil(total / Number(limit))
      }
    });
  } catch (error) {
    console.error('Get users error:', error);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
};

// Get specific user details
export const getUserDetails = async (req: Request, res: Response) => {
  try {
    const { user_id } = req.params;

    const user = await prisma.user.findUnique({
      where: { user_id: Number(user_id) },
      include: {
        adventurerProfile: true,
        coachProfile: true,
        adminProfile: true
      }
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Get additional stats using raw queries for tables not in Prisma schema
    const additionalStats = await prisma.$queryRaw`
      SELECT 
        (SELECT COUNT(*) FROM quest_completion_history WHERE user_id = ${Number(user_id)}) as completed_quests,
        (SELECT COUNT(*) FROM achievements_earned WHERE user_id = ${Number(user_id)}) as achievements,
        (SELECT COUNT(*) FROM daily_checkins WHERE user_id = ${Number(user_id)}) as checkins
    `;

    res.json({
      user,
      stats: additionalStats[0]
    });
  } catch (error) {
    console.error('Get user details error:', error);
    res.status(500).json({ error: 'Failed to fetch user details' });
  }
};

// Delete user
export const deleteUser = async (req: Request, res: Response) => {
  try {
    const { user_id } = req.params;
    const adminUser = (req as any).user;

    // Get user info before deletion
    const userToDelete = await prisma.user.findUnique({
      where: { user_id: Number(user_id) },
      select: { username: true, email: true, user_type: true }
    });

    if (!userToDelete) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Prevent deleting super admins
    if (userToDelete.user_type === 'admin') {
      const targetAdmin = await prisma.adminProfile.findUnique({
        where: { user_id: Number(user_id) }
      });
      
      if (targetAdmin?.access_level === 'SUPER_ADMIN') {
        return res.status(403).json({ error: 'Cannot delete super admin' });
      }
    }

    // Delete user (cascades to profiles)
    await prisma.user.delete({
      where: { user_id: Number(user_id) }
    });

    // Log admin action
    await logAdminAction(
      adminUser.user_id,
      'DELETE_USER',
      'user',
      Number(user_id),
      { deletedUser: userToDelete },
      req
    );

    res.json({ 
      message: 'User deleted successfully',
      deletedUser: userToDelete
    });
  } catch (error) {
    console.error('Delete user error:', error);
    res.status(500).json({ error: 'Failed to delete user' });
  }
};

// Toggle user status
export const toggleUserStatus = async (req: Request, res: Response) => {
  try {
    const { user_id } = req.params;
    const adminUser = (req as any).user;

    const user = await prisma.user.findUnique({
      where: { user_id: Number(user_id) }
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    const updatedUser = await prisma.user.update({
      where: { user_id: Number(user_id) },
      data: { is_active: !user.is_active }
    });

    // Log admin action
    await logAdminAction(
      adminUser.user_id,
      user.is_active ? 'DEACTIVATE_USER' : 'ACTIVATE_USER',
      'user',
      Number(user_id),
      { newStatus: updatedUser.is_active },
      req
    );

    res.json({
      message: `User ${updatedUser.is_active ? 'activated' : 'deactivated'} successfully`,
      user: updatedUser
    });
  } catch (error) {
    console.error('Toggle user status error:', error);
    res.status(500).json({ error: 'Failed to update user status' });
  }
};

// Get admin activity logs
export const getAdminLogs = async (req: Request, res: Response) => {
  try {
    const { page = 1, limit = 20 } = req.query;
    const skip = (Number(page) - 1) * Number(limit);

    const [logs, total] = await Promise.all([
      prisma.adminActionLog.findMany({
        skip,
        take: Number(limit),
        orderBy: { created_at: 'desc' }
      }),
      prisma.adminActionLog.count()
    ]);

    // Get admin usernames
    const adminIds = [...new Set(logs.map(log => log.admin_user_id))];
    const admins = await prisma.user.findMany({
      where: { user_id: { in: adminIds } },
      select: { user_id: true, username: true }
    });

    const adminMap = new Map(admins.map(a => [a.user_id, a.username]));

    const logsWithAdminNames = logs.map(log => ({
      ...log,
      admin_username: adminMap.get(log.admin_user_id) || 'Unknown'
    }));

    res.json({
      logs: logsWithAdminNames,
      pagination: {
        total,
        page: Number(page),
        limit: Number(limit),
        pages: Math.ceil(total / Number(limit))
      }
    });
  } catch (error) {
    console.error('Get admin logs error:', error);
    res.status(500).json({ error: 'Failed to fetch admin logs' });
  }
};


// Create new user from admin panel
export const createUser = async (req: Request, res: Response) => {
  try {
    const { email, username, password, user_type, full_name, ...profileData } = req.body;
    const adminUser = (req as any).user;

    // Validate required fields
    if (!email || !username || !password || !user_type || !full_name) {
      return res.status(400).json({ 
        error: 'Missing required fields: email, username, password, user_type, full_name' 
      });
    }

    // Check if user exists
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [
          { email },
          { username }
        ]
      }
    });

    if (existingUser) {
      return res.status(400).json({ 
        error: 'User with this email or username already exists' 
      });
    }

    // Hash password
    const bcrypt = require('bcrypt');
    const password_hash = await bcrypt.hash(password, 10);

    // Create user with profile in a transaction
    const newUser = await prisma.$transaction(async (tx) => {
      const user = await tx.user.create({
        data: {
          email,
          username,
          password_hash,
          user_type: user_type as any,
          is_active: true
        }
      });

      // Create appropriate profile
      if (user_type === 'adventurer') {
        await tx.adventurerProfile.create({
          data: {
            user_id: user.user_id,
            full_name,
            field_of_interest: profileData.field_of_interest || 'General',
            commitment_level: profileData.commitment_level || 'one_hour',
            experience_level: profileData.experience_level || 'beginner',
          
          }
        });
      } else if (user_type === 'coach') {
        await tx.coachProfile.create({
          data: {
            user_id: user.user_id,
            full_name,
            specialization: profileData.field_of_interest || 'General',
            verification_status: 'pending'
          }
        });
      }

      return user;
    });

    // Log admin action
    await logAdminAction(
      adminUser.user_id,
      'CREATE_USER',
      'user',
      newUser.user_id,
      { createdUser: { email, username, user_type } },
      req
    );

    res.status(201).json({
      message: 'User created successfully',
      user: newUser
    });
  } catch (error) {
    console.error('Create user error:', error);
    res.status(500).json({ error: 'Failed to create user' });
  }
};

// Update user
export const updateUser = async (req: Request, res: Response) => {
  try {
    const { user_id } = req.params;
    const { email, username, is_active, ...updateData } = req.body;
    const adminUser = (req as any).user;

    const updates: any = {};
    
    if (email !== undefined) updates.email = email;
    if (username !== undefined) updates.username = username;
    if (is_active !== undefined) updates.is_active = is_active;

    const updatedUser = await prisma.user.update({
      where: { user_id: Number(user_id) },
      data: updates
    });

    // Log admin action
    await logAdminAction(
      adminUser.user_id,
      'UPDATE_USER',
      'user',
      Number(user_id),
      { updates },
      req
    );

    res.json({
      message: 'User updated successfully',
      user: updatedUser
    });
  } catch (error) {
    console.error('Update user error:', error);
    res.status(500).json({ error: 'Failed to update user' });
  }
};

// Get all quests
export const getAllQuests = async (req: Request, res: Response) => {
  try {
    const { page = 1, limit = 20 } = req.query;
    const skip = (Number(page) - 1) * Number(limit);

    const quests = await prisma.$queryRaw`
      SELECT * FROM active_quests 
      ORDER BY created_at DESC 
      LIMIT ${Number(limit)} OFFSET ${skip}
    `;

    const totalResult = await prisma.$queryRaw`
      SELECT COUNT(*) as count FROM active_quests
    `;
    const total = (totalResult as any)[0].count;

    res.json({
      quests,
      pagination: {
        total,
        page: Number(page),
        limit: Number(limit),
        pages: Math.ceil(total / Number(limit))
      }
    });
  } catch (error) {
    console.error('Get quests error:', error);
    res.status(500).json({ error: 'Failed to fetch quests' });
  }
};

// Get database statistics
export const getDatabaseStats = async (req: Request, res: Response) => {
  try {
    const tables = [
      'users', 
      'adventurer_profiles', 
      'coach_profiles',
      'admin_profiles',
      'active_quests', 
      'quest_completion_history', 
      'achievements_earned', 
      'user_achievements',
      'daily_checkins', 
      'activity_logs',
      'admin_action_logs'
    ];

    const stats = await Promise.all(
      tables.map(async (table) => {
        try {
          const result = await prisma.$queryRawUnsafe(`SELECT COUNT(*) as count FROM ${table}`);
          return { table, count: (result as any)[0].count };
        } catch {
          return { table, count: 0, error: 'Table not found' };
        }
      })
    );

    res.json({ tableStats: stats });
  } catch (error) {
    console.error('Get database stats error:', error);
    res.status(500).json({ error: 'Failed to fetch database statistics' });
  }
};

// Helper function to log admin actions
async function logAdminAction(
  admin_user_id: number,
  action_type: string,
  target_type: string | null,
  target_id: number | null,
  details: any,
  req: Request
) {
  try {
    await prisma.adminActionLog.create({
      data: {
        admin_user_id,
        action_type,
        target_type,
        target_id,
        action_details: details,
        ip_address: req.ip,
        user_agent: req.get('user-agent') || null
      }
    });
  } catch (error) {
    console.error('Failed to log admin action:', error);
  }
}

// Update admin's last action
async function updateAdminLastAction(admin_user_id: number, action: string) {
  try {
    await prisma.adminProfile.update({
      where: { user_id: admin_user_id },
      data: {
        last_action: action,
        last_action_date: new Date()
      }
    });
  } catch (error) {
    console.error('Failed to update admin last action:', error);
  }
}
export const getAllQuestsDetailed = async (req: Request, res: Response) => {
  try {
    const { page = 1, limit = 15, status } = req.query;
    const skip = (Number(page) - 1) * Number(limit);

    const connection = await pool.getConnection();

    try {
      let whereClause = '';
      let countWhereClause = '';
      
      if (status === 'active') {
        whereClause = 'WHERE uaq.is_completed = FALSE';
        countWhereClause = 'WHERE is_completed = FALSE';
      } else if (status === 'completed') {
        whereClause = 'WHERE uaq.is_completed = TRUE';
        countWhereClause = 'WHERE is_completed = TRUE';
      }

      // ✅ Using user_active_quests (the main table)
      const [quests]: any = await connection.execute(`
        SELECT 
          uaq.active_quest_id,
          uaq.user_id,
          uaq.quest_template_id,
          uaq.quest_type,
          uaq.assigned_date,
          uaq.expires_at,
          uaq.is_completed,
          uaq.completed_at,
          uaq.xp_earned,
          uaq.created_at,
          qt.quest_title,
          qt.quest_description,
          qt.base_xp,
          qt.difficulty,
          qt.related_stat,
          u.username,
          u.email,
          ap.full_name,
          ap.field_of_interest
        FROM user_active_quests uaq
        LEFT JOIN quest_templates qt ON uaq.quest_template_id = qt.quest_template_id
        LEFT JOIN users u ON uaq.user_id = u.user_id
        LEFT JOIN adventurer_profiles ap ON uaq.user_id = ap.user_id
        ${whereClause}
        ORDER BY uaq.created_at DESC
        LIMIT ${Number(limit)} OFFSET ${skip}
      `);

      const [totalResult]: any = await connection.execute(`
        SELECT COUNT(*) as count 
        FROM user_active_quests
        ${countWhereClause}
      `);
      
      const total = totalResult[0].count;

      connection.release();

      res.json({
        quests,
        pagination: {
          total: Number(total),
          page: Number(page),
          limit: Number(limit),
          pages: Math.ceil(Number(total) / Number(limit))
        }
      });
    } catch (error) {
      connection.release();
      throw error;
    }
  } catch (error) {
    console.error('Get quests detailed error:', error);
    res.status(500).json({ 
      error: 'Failed to fetch quests',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
};







src/controller/authController.ts
import { Request, Response } from 'express';
import pool from '../config/database';
import prisma from '../config/prisma'; 
import { initializeNewUserQuests } from '../schedulers/questScheduler';
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const fs = require('fs').promises;
const crypto = require('crypto');

// Helper function to get client IP address
const getClientIP = (req: Request): string => {
  return (req.headers['x-forwarded-for'] as string) ||
         (req.headers['x-real-ip'] as string) ||
         (req.connection?.remoteAddress) ||
         (req.socket?.remoteAddress) ||
         req.ip ||
         'unknown';
};

// Helper function to get user agent
const getUserAgent = (req: Request): string => {
  return req.headers['user-agent'] || 'unknown';
};

// Generate session ID
const generateSessionId = (): string => {
  return crypto.randomBytes(32).toString('hex');
};

// Password validation function
const validatePassword = (password: string): { isValid: boolean; message?: string } => {
  // Check minimum length (at least 6 characters)
  if (password.length < 6) {
    return { isValid: false, message: 'Password must be at least 6 characters long' };
  }

  // Check for at least one uppercase letter
  if (!/[A-Z]/.test(password)) {
    return { isValid: false, message: 'Password must contain at least one uppercase letter' };
  }

  // Check for at least one lowercase letter
  if (!/[a-z]/.test(password)) {
    return { isValid: false, message: 'Password must contain at least one lowercase letter' };
  }

  // Check for at least one number
  if (!/[0-9]/.test(password)) {
    return { isValid: false, message: 'Password must contain at least one number' };
  }

  // Check for exactly one special character
  const specialCharCount = (password.match(/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/g) || []).length;
  if (specialCharCount !== 1) {
    return { isValid: false, message: 'Password must contain exactly one special character (e.g., @, #, $, etc.)' };
  }

  return { isValid: true };
};

// Update your signup function in authController.ts with better error handling:

export const signup = async (req: Request, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const { email, username, password, user_type, full_name, field_of_interest, commitment_level, experience_level } = req.body;
    
    // Check if user already exists
    const [existing]: any = await connection.execute(
      'SELECT user_id, email, username FROM users WHERE email = ? OR username = ?',
      [email, username]
    );
    
    if (existing.length > 0) {
      await connection.rollback();
      return res.status(400).json({ error: 'User already exists' });
    }
    
    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // Handle profile photo
    let profilePhotoUrl = null;
    if (req.file) {
      const file = req.file as any;
      profilePhotoUrl = `/uploads/profiles/${file.filename}`;
      
      // Move file from temp to profiles
      const oldPath = file.path;
      const newPath = `uploads/profiles/${file.filename}`;
      await fs.rename(oldPath, newPath);
    }
    
    // Create user
    const [userResult]: any = await connection.execute(
      'INSERT INTO users (email, username, password_hash, user_type, profile_photo_url) VALUES (?, ?, ?, ?, ?)',
      [email, username, hashedPassword, user_type, profilePhotoUrl]
    );
    
    const userId = userResult.insertId;
    console.log(`Created user with ID: ${userId}`);
    
    // Create profile based on user type
    if (user_type === 'adventurer') {
      // Check if profile already exists (safety check)
      const [existingProfile]: any = await connection.execute(
        'SELECT user_id FROM adventurer_profiles WHERE user_id = ?',
        [userId]
      );
      
      if (existingProfile.length === 0) {
        await connection.execute(
          'INSERT INTO adventurer_profiles (user_id, full_name, field_of_interest, commitment_level, experience_level) VALUES (?, ?, ?, ?, ?)',
          [userId, full_name, field_of_interest, commitment_level, experience_level]
        );
        console.log(`Created adventurer profile for user ${userId}`);
      } else {
        console.log(`Adventurer profile already exists for user ${userId}`);
      }
      
    } else if (user_type === 'coach') {
      // Check if profile already exists (safety check)
      const [existingProfile]: any = await connection.execute(
        'SELECT user_id FROM coach_profiles WHERE user_id = ?',
        [userId]
      );
      
      if (existingProfile.length === 0) {
        await connection.execute(
          'INSERT INTO coach_profiles (user_id, full_name, specialization) VALUES (?, ?, ?)',
          [userId, full_name, field_of_interest]
        );
        console.log(`Created coach profile for user ${userId}`);
      } else {
        console.log(`Coach profile already exists for user ${userId}`);
      }
    }
    
    await connection.commit();
    console.log(`Successfully completed signup for user ${userId}`);
    
    // Generate token
    const token = jwt.sign(
      { user_id: userId, email, user_type },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );
    
    // Log signup activity
    try {
      await connection.execute(
        'INSERT INTO activity_logs (user_id, activity_type, activity_details, ip_address, user_agent) VALUES (?, ?, ?, ?, ?)',
        [userId, 'signup', JSON.stringify({ account_created: true }), getClientIP(req), getUserAgent(req)]
      );
    } catch (logError) {
      console.warn('Failed to log signup activity:', logError);
    }
    
    res.status(201).json({
      message: 'User created successfully',
      token,
      user: {
        user_id: userId,
        email,
        username,
        user_type,
        profile_photo_url: profilePhotoUrl
          ? `${process.env.BASE_URL || 'http://localhost:5000'}${profilePhotoUrl}`
          : null
      }
    });
    
  } catch (error: any) {
    await connection.rollback();
    console.error('Signup error:', error);
    res.status(500).json({ error: 'Failed to create account. Please try again.' });
  } finally {
    connection.release();
  }
};
export const login = async (req: Request, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const { email, password } = req.body;
    const clientIP = getClientIP(req);
    const userAgent = getUserAgent(req);
    
    // Input validation
    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required' });
    }
    
    // ==================== HARDCODED ADMIN CHECK (ADD THIS) ====================
// Check if this is an admin login attempt
const ADMIN_EMAIL = process.env.ADMIN_EMAIL || 'admin@sololeveling.com';
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || 'Admin@123456';

if (email === ADMIN_EMAIL) {
  // Admin login - verify password directly (no bcrypt for admin)
  if (password !== ADMIN_PASSWORD) {
    console.log('❌ Admin login failed: Invalid password');
    return res.status(401).json({ error: 'Invalid credentials' });
  }

  console.log('✅ Admin login successful');

  // Generate session ID and JWT token for admin
  const sessionId = generateSessionId();
  const adminUserId = 9999; // Virtual admin user ID

  const token = jwt.sign(
    { 
      user_id: adminUserId,
      email: ADMIN_EMAIL,
      user_type: 'admin',
      session_id: sessionId,
      isHardcodedAdmin: true // Special flag for admin
    },
    process.env.JWT_SECRET,
    { expiresIn: '7d' }
  );

  // Log admin login action using Prisma
  try {
    await prisma.adminActionLog.create({
      data: {
        admin_user_id: adminUserId,
        action_type: 'ADMIN_LOGIN',
        action_details: {
          login_time: new Date().toISOString(),
          ip_address: clientIP,
          user_agent: userAgent,
          type: 'hardcoded_admin'
        },
        ip_address: clientIP,
        user_agent: userAgent
      }
    });
  } catch (logError) {
    console.warn('Failed to log admin action:', logError);
  }

  await connection.commit();
  connection.release();

  // Return admin response
  return res.json({
    message: 'Admin login successful',
    token,
    user: {
      user_id: adminUserId,
      email: ADMIN_EMAIL,
      username: 'SystemAdmin',
      user_type: 'admin',
      profile_photo_url: null,
      is_active: true
    },
    profile: {
      full_name: 'System Administrator',
      department: 'System Administration',
      access_level: 'SUPER_ADMIN'
    },
    session: {
      session_id: sessionId,
      expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    }
  });
}
// ==================== END HARDCODED ADMIN CHECK ====================

    // Get user with additional fields for security
    const [users]: any = await connection.execute(
      'SELECT user_id, email, username, password_hash, user_type, profile_photo_url, is_active, email_verified FROM users WHERE email = ?',
      [email]
    );
    
    if (users.length === 0) {
      // Log failed login attempt
      try {
        await connection.execute(
          'INSERT INTO activity_logs (user_id, activity_type, activity_details, ip_address, user_agent) VALUES (?, ?, ?, ?, ?)',
          [null, 'login_failed', JSON.stringify({ reason: 'user_not_found', email: email }), clientIP, userAgent]
        );
      } catch (logError) {
        console.warn('Failed to log failed login attempt:', logError);
      }
      
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    const user = users[0];
    
    // Check if user account is active
    if (!user.is_active) {
      // Log failed login attempt
      try {
        await connection.execute(
          'INSERT INTO activity_logs (user_id, activity_type, activity_details, ip_address, user_agent) VALUES (?, ?, ?, ?, ?)',
          [user.user_id, 'login_failed', JSON.stringify({ reason: 'account_inactive' }), clientIP, userAgent]
        );
      } catch (logError) {
        console.warn('Failed to log failed login attempt:', logError);
      }
      
      return res.status(401).json({ error: 'Account is disabled' });
    }
    
    // Verify password
    const isValidPassword = await bcrypt.compare(password, user.password_hash);
    if (!isValidPassword) {
      // Log failed login attempt
      try {
        await connection.execute(
          'INSERT INTO activity_logs (user_id, activity_type, activity_details, ip_address, user_agent) VALUES (?, ?, ?, ?, ?)',
          [user.user_id, 'login_failed', JSON.stringify({ reason: 'invalid_password' }), clientIP, userAgent]
        );
      } catch (logError) {
        console.warn('Failed to log failed login attempt:', logError);
      }
      
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Generate session ID and JWT token
    const sessionId = generateSessionId();
    const token = jwt.sign(
      { 
        user_id: user.user_id, 
        email: user.email, 
        user_type: user.user_type,
        session_id: sessionId
      },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );
    
    // Create session in database (this will trigger the update_last_login trigger)
    const sessionExpiry = new Date();
    sessionExpiry.setDate(sessionExpiry.getDate() + 7); // 7 days from now
    
    try {
      await connection.execute(
        'INSERT INTO user_sessions (session_id, user_id, expires_at, ip_address, user_agent) VALUES (?, ?, ?, ?, ?)',
        [sessionId, user.user_id, sessionExpiry, clientIP, userAgent]
      );
    } catch (sessionError) {
      console.error('Failed to create session:', sessionError);
      // Continue without session creation if it fails
    }
    
    // Get user profile
   // Get user profile based on user type
let profile = null;
if (user.user_type === 'adventurer') {
  // Keep existing MySQL connection for adventurer
  const [profiles]: any = await connection.execute(
    'SELECT * FROM adventurer_profiles WHERE user_id = ?',
    [user.user_id]
  );
  profile = profiles[0];
} else if (user.user_type === 'coach') {
  // Keep existing MySQL connection for coach
  const [profiles]: any = await connection.execute(
    'SELECT * FROM coach_profiles WHERE user_id = ?',
    [user.user_id]
  );
  profile = profiles[0];
} else if (user.user_type === 'admin') {
  // USE PRISMA ONLY FOR ADMIN
  try {
    const adminProfile = await prisma.adminProfile.findUnique({
      where: { user_id: user.user_id }
    });
    
    if (adminProfile) {
      // Update admin's last action using Prisma
      await prisma.adminProfile.update({
        where: { user_id: user.user_id },
        data: {
          last_action: 'LOGIN',
          last_action_date: new Date()
        }
      });
      
      // Log admin login action using Prisma
      await prisma.adminActionLog.create({
        data: {
          admin_user_id: user.user_id,
          action_type: 'ADMIN_LOGIN',
          action_details: {
            login_time: new Date().toISOString(),
            ip_address: clientIP,
            user_agent: userAgent
          },
          ip_address: clientIP,
          user_agent: userAgent
        }
      });
      
      profile = adminProfile;
    }
  } catch (prismaError) {
    console.error('Prisma admin profile error:', prismaError);
    // If Prisma fails, you can fallback to regular query or handle the error
  }
}
    
    // Update last login manually if triggers don't work
    try {
      await connection.execute(
        'UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE user_id = ?',
        [user.user_id]
      );
    } catch (updateError) {
      console.warn('Failed to update last_login:', updateError);
    }
    
    // Log successful login activity manually if trigger doesn't work
    try {
      await connection.execute(
        'INSERT INTO activity_logs (user_id, activity_type, activity_details, ip_address, user_agent) VALUES (?, ?, ?, ?, ?)',
        [user.user_id, 'login', JSON.stringify({ 
          session_created: true, 
          session_id: sessionId,
          login_time: new Date().toISOString()
        }), clientIP, userAgent]
      );
    } catch (logError) {
      console.warn('Failed to log login activity:', logError);
    }
    
    await connection.commit();
    
    // Clean up old sessions (optional, for maintenance)
    try {
      await connection.execute(
        'DELETE FROM user_sessions WHERE user_id = ? AND expires_at < NOW()',
        [user.user_id]
      );
    } catch (cleanupError) {
      console.warn('Failed to cleanup old sessions:', cleanupError);
    }
    console.log("DEBUG login user response:", {
  user_id: user.user_id,
  email: user.email,
  username: user.username,
  user_type: user.user_type,
  profile_photo_url: user.profile_photo_url
    ? `${process.env.BASE_URL || 'http://localhost:5000'}${user.profile_photo_url}`
    : null
});
    res.json({
  message: 'Login successful',
  token,
  user: {
    user_id: user.user_id,
    email: user.email,
    username: user.username,
    user_type: user.user_type,
    profile_photo_url: user.profile_photo_url 
      ? `${process.env.BASE_URL || 'http://localhost:5000'}${user.profile_photo_url}`
      : null
  },
  profile,
  session: {
    session_id: sessionId,
    expires_at: sessionExpiry
  }
});
    
  } catch (error: any) {
    await connection.rollback();
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed. Please try again.' });
  } finally {
    connection.release();
  }
};

// New logout function to handle session cleanup
export const logout = async (req: Request, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (token) {
      // Decode token to get session info
      const decoded = jwt.verify(token, process.env.JWT_SECRET) as any;
      const userId = decoded.user_id;
      const sessionId = decoded.session_id;
      
      // Remove session from database
      if (sessionId) {
        await connection.execute(
          'DELETE FROM user_sessions WHERE session_id = ? AND user_id = ?',
          [sessionId, userId]
        );
      }
      
      // Log logout activity
      try {
        await connection.execute(
          'INSERT INTO activity_logs (user_id, activity_type, activity_details, ip_address, user_agent) VALUES (?, ?, ?, ?, ?)',
          [userId, 'logout', JSON.stringify({ 
            session_ended: true,
            session_id: sessionId,
            logout_time: new Date().toISOString()
          }), getClientIP(req), getUserAgent(req)]
        );
      } catch (logError) {
        console.warn('Failed to log logout activity:', logError);
      }
    }
    
    res.json({ message: 'Logged out successfully' });
    
  } catch (error: any) {
    console.error('Logout error:', error);
    res.status(500).json({ error: 'Logout failed' });
  } finally {
    connection.release();
  }
};

// Function to validate session (for middleware use)
export const validateSession = async (sessionId: string, userId: number): Promise<boolean> => {
  const connection = await pool.getConnection();
  
  try {
    const [sessions]: any = await connection.execute(
      'SELECT session_id FROM user_sessions WHERE session_id = ? AND user_id = ? AND expires_at > NOW()',
      [sessionId, userId]
    );
    
    return sessions.length > 0;
  } catch (error) {
    console.error('Session validation error:', error);
    return false;
  } finally {
    connection.release();
  }
};

// Function to get login statistics (for admin/analytics)
export const getLoginStats = async (req: Request, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    // Get recent login activities
    const [recentLogins]: any = await connection.execute(`
      SELECT 
        u.username,
        u.email,
        al.created_at as login_time,
        al.ip_address,
        al.activity_details
      FROM activity_logs al
      JOIN users u ON al.user_id = u.user_id
      WHERE al.activity_type = 'login'
      ORDER BY al.created_at DESC
      LIMIT 50
    `);
    
    // Get daily login counts for the last 30 days
    const [dailyStats]: any = await connection.execute(`
      SELECT 
        DATE(created_at) as date,
        COUNT(*) as login_count
      FROM activity_logs
      WHERE activity_type = 'login' 
        AND created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
      GROUP BY DATE(created_at)
      ORDER BY date DESC
    `);
    
    // Get total active sessions
    const [activeSessions]: any = await connection.execute(`
      SELECT COUNT(*) as active_sessions
      FROM user_sessions
      WHERE expires_at > NOW()
    `);
    
    res.json({
      recent_logins: recentLogins,
      daily_stats: dailyStats,
      active_sessions: activeSessions[0].active_sessions
    });
    
  } catch (error: any) {
    console.error('Failed to get login stats:', error);
    res.status(500).json({ error: 'Failed to retrieve login statistics' });
  } finally {
    connection.release();
  }
};






src/controller/coachController.ts
import { Request, Response } from 'express';
import { AuthRequest } from '../middleware/auth';
import pool from '../config/database';

export const verifyAndGetStudent = async (req: AuthRequest, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    const coachId = req.user?.user_id;
    const { student_email, student_name, field_of_interest } = req.body;
    
    // Verify student
    const [students]: any = await connection.execute(
      `SELECT u.user_id
      FROM users u
      JOIN adventurer_profiles ap ON u.user_id = ap.user_id
      WHERE u.email = ? AND ap.full_name = ? AND ap.field_of_interest = ?`,
      [student_email, student_name, field_of_interest]
    );
    
    if (students.length === 0) {
      return res.status(404).json({ error: 'Student not found' });
    }
    
    const studentId = students[0].user_id;
    
    // Create relationship
    await connection.execute(
      `INSERT INTO coach_student_relationships (coach_user_id, student_user_id, status)
      VALUES (?, ?, 'active')
      ON DUPLICATE KEY UPDATE status = 'active'`,
      [coachId, studentId]
    );
    
    // Get student data
    const [profile]: any = await connection.execute(
      'SELECT * FROM adventurer_profiles WHERE user_id = ?',
      [studentId]
    );
    
    const [stats]: any = await connection.execute(
      'SELECT * FROM user_stats WHERE user_id = ?',
      [studentId]
    );
    
    res.json({
      student_profile: profile[0],
      student_stats: stats
    });
    
  } catch (error: any) {
    console.error('Verify student error:', error);
    res.status(500).json({ error: 'Failed to verify student' });
  } finally {
    connection.release();
  }
};

export const getMyStudents = async (req: AuthRequest, res: Response) => {
  try {
    const coachId = req.user?.user_id;
    
    const [students]: any = await pool.execute(
      `SELECT 
        u.user_id,
        u.username,
        u.email,
        ap.full_name,
        ap.field_of_interest,
        ap.current_level,
        ap.total_exp,
        ap.streak_days
      FROM coach_student_relationships csr
      JOIN users u ON u.user_id = csr.student_user_id
      JOIN adventurer_profiles ap ON ap.user_id = csr.student_user_id
      WHERE csr.coach_user_id = ? AND csr.status = 'active'`,
      [coachId]
    );
    
    res.json({ students });
  } catch (error: any) {
    console.error('Get students error:', error);
    res.status(500).json({ error: 'Failed to fetch students' });
  }
};

export const provideFeedback = async (req: AuthRequest, res: Response) => {
  try {
    const coachId = req.user?.user_id;
    const { student_id, feedback_type, feedback_text, rating } = req.body;
    
    // Insert feedback
    await pool.execute(
      'INSERT INTO coach_feedback (coach_user_id, student_user_id, feedback_type, feedback_text, rating) VALUES (?, ?, ?, ?, ?)',
      [coachId, student_id, feedback_type, feedback_text, rating || null]
    );
    
    res.json({ message: 'Feedback provided successfully' });
    
  } catch (error: any) {
    console.error('Provide feedback error:', error);
    res.status(500).json({ error: 'Failed to provide feedback' });
  }
};

// Add this to your existing coachController.ts
export const removeStudent = async (req: AuthRequest, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const coachId = req.user?.user_id;
    const studentId = req.params.student_id;
    
    // Validate student_id parameter
    if (!studentId) {
      await connection.rollback();
      return res.status(400).json({ error: 'Student ID is required' });
    }
    
    // Verify the relationship exists and the coach owns it
    const [existingRelationship]: any = await connection.execute(
      `SELECT csr.*, u.username, ap.full_name 
       FROM coach_student_relationships csr
       JOIN users u ON u.user_id = csr.student_user_id
       JOIN adventurer_profiles ap ON ap.user_id = csr.student_user_id
       WHERE csr.coach_user_id = ? AND csr.student_user_id = ? AND csr.status = 'active'`,
      [coachId, studentId]
    );
    
    if (existingRelationship.length === 0) {
      await connection.rollback();
      return res.status(404).json({ error: 'Student not found in your roster or already removed' });
    }
    
    const student = existingRelationship[0];
    
    // Remove the relationship (hard delete)
    const [deleteResult]: any = await connection.execute(
      'DELETE FROM coach_student_relationships WHERE coach_user_id = ? AND student_user_id = ?',
      [coachId, studentId]
    );
    
    if (deleteResult.affectedRows === 0) {
      await connection.rollback();
      return res.status(500).json({ error: 'Failed to remove student from roster' });
    }
    
    // Log the removal activity for audit purposes
    try {
      await connection.execute(
        `INSERT INTO activity_logs (user_id, activity_type, activity_details, ip_address, user_agent) 
         VALUES (?, ?, ?, ?, ?)`,
        [
          coachId, 
          'student_removed', 
          JSON.stringify({ 
            removed_student_id: studentId,
            removed_student_name: student.full_name,
            action: 'coach_removed_student',
            timestamp: new Date().toISOString()
          }),
          req.ip || 'unknown',
          req.headers['user-agent'] || 'unknown'
        ]
      );
    } catch (logError) {
      console.warn('Failed to log student removal activity:', logError);
      // Continue with the operation even if logging fails
    }
    
    // Also log from student's perspective (optional)
    try {
      await connection.execute(
        `INSERT INTO activity_logs (user_id, activity_type, activity_details, ip_address, user_agent) 
         VALUES (?, ?, ?, ?, ?)`,
        [
          studentId, 
          'coach_relationship_ended', 
          JSON.stringify({ 
            coach_id: coachId,
            action: 'removed_by_coach',
            timestamp: new Date().toISOString()
          }),
          req.ip || 'unknown',
          req.headers['user-agent'] || 'unknown'
        ]
      );
    } catch (logError) {
      console.warn('Failed to log coach relationship ended activity:', logError);
    }
    
    await connection.commit();
    
    res.json({ 
      message: 'Student removed from roster successfully',
      removed_student: {
        user_id: studentId,
        name: student.full_name,
        username: student.username
      }
    });
    
  } catch (error: any) {
    await connection.rollback();
    console.error('Remove student error:', error);
    res.status(500).json({ error: 'Failed to remove student from roster' });
  } finally {
    connection.release();
  }
};
export const getStudentStats = async (req: AuthRequest, res: Response) => {
  try {
    const coachId = req.user?.user_id;
    const { student_id } = req.params;

    // Verify the coach has access to this student
    const [relationship]: any = await pool.execute(
      `SELECT csr.* FROM coach_student_relationships csr 
       WHERE csr.coach_user_id = ? AND csr.student_user_id = ? AND csr.status = 'active'`,
      [coachId, student_id]
    );

    if (relationship.length === 0) {
      return res.status(403).json({ error: 'No access to this student' });
    }

    // Get student profile
    const [profile]: any = await pool.execute(
      'SELECT * FROM adventurer_profiles WHERE user_id = ?',
      [student_id]
    );

    // Get student stats
    const [stats]: any = await pool.execute(
      'SELECT * FROM user_stats WHERE user_id = ? ORDER BY stat_name',
      [student_id]
    );

    // Get student's quest completion data
    const [quests]: any = await pool.execute(
      `SELECT 
        COUNT(*) as total_quests_completed,
        COUNT(CASE WHEN DATE(completed_at) = CURDATE() THEN 1 END) as quests_today,
        COUNT(CASE WHEN completed_at >= DATE_SUB(NOW(), INTERVAL 7 DAY) THEN 1 END) as quests_this_week
       FROM quest_completion_history 
       WHERE user_id = ?`,
      [student_id]
    );

    // Get student's achievements
    const [achievements]: any = await pool.execute(
      `SELECT ua.*, a.achievement_name, a.achievement_description, a.achievement_icon
       FROM user_achievements ua
       JOIN achievements a ON ua.achievement_id = a.achievement_id
       WHERE ua.user_id = ?
       ORDER BY ua.earned_at DESC`,
      [student_id]
    );

    res.json({
      student_profile: profile[0] || null,
      student_stats: stats || [],
      quest_progress: quests[0] || { total_quests_completed: 0, quests_today: 0, quests_this_week: 0 },
      achievements: achievements || []
    });

  } catch (error: any) {
    console.error('Get student stats error:', error);
    res.status(500).json({ error: 'Failed to fetch student stats' });
  }
};




src/controller/questController.ts
import { Request, Response } from 'express';
import { AuthRequest } from '../middleware/auth';
import pool from '../config/database';
interface QuestTemplate {
  quest_template_id: number;
  quest_title: string;
  quest_description: string;
  base_xp: number;
  difficulty: string;
  related_stat: string;
  field_name: string;
  quest_type: string;
  is_active: boolean;
}
/**
 * Fisher-Yates Shuffle Algorithm - for perfect randomization
 * @param array - Array to shuffle
 * @returns Shuffled array
 */
export const shuffleArray = <T>(array: T[]): T[] => {
  const shuffled = [...array]; // Create a copy
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
};

/**
 * Advanced uniqueness checker - checks for similar quest titles
 * @param questTitle - Title to check
 * @param existingTitles - Set of existing titles
 * @returns boolean - true if unique enough
 */
export const isQuestUnique = (questTitle: string, existingTitles: Set<string>): boolean => {
  const normalizedTitle = questTitle.toLowerCase().trim();
  
  // Direct match check
  if (existingTitles.has(normalizedTitle)) {
    return false;
  }
  
  // Similar title check (optional - prevents very similar quests)
  for (const existingTitle of existingTitles) {
    // Check if titles are too similar (more than 70% similar)
    const similarity = calculateSimilarity(normalizedTitle, existingTitle);
    if (similarity > 0.7) {
      console.log(`Skipping similar quest: "${questTitle}" (${similarity}% similar to "${existingTitle}")`);
      return false;
    }
  }
  
  return true;
};

/**
 * Calculate similarity between two strings (simple version)
 * @param str1 - First string
 * @param str2 - Second string
 * @returns number - Similarity score (0-1)
 */
export const calculateSimilarity = (str1: string, str2: string): number => {
  const longer = str1.length > str2.length ? str1 : str2;
  const shorter = str1.length > str2.length ? str2 : str1;
  
  if (longer.length === 0) return 1.0;
  
  const distance = levenshteinDistance(longer, shorter);
  return (longer.length - distance) / longer.length;
};

/**
 * Levenshtein distance calculation
 */
export const levenshteinDistance = (str1: string, str2: string): number => {
  const matrix = [];
  
  for (let i = 0; i <= str2.length; i++) {
    matrix[i] = [i];
  }
  
  for (let j = 0; j <= str1.length; j++) {
    matrix[0][j] = j;
  }
  
  for (let i = 1; i <= str2.length; i++) {
    for (let j = 1; j <= str1.length; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }
  
  return matrix[str2.length][str1.length];
};



export const getDailyQuests = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.user_id;
    
    const [quests]: any = await pool.execute(
      `SELECT 
        uaq.*,
        qt.quest_title,
        qt.quest_description,
        qt.base_xp,
        qt.difficulty,
        qt.related_stat
      FROM user_active_quests uaq
      LEFT JOIN quest_templates qt ON uaq.quest_template_id = qt.quest_template_id
      WHERE uaq.user_id = ?
      AND uaq.quest_type = 'daily'
      AND uaq.expires_at > NOW()`,
      [userId]
    );
    
    res.json({ quests });
  } catch (error: any) {
    console.error('Get daily quests error:', error);
    res.status(500).json({ error: 'Failed to fetch quests' });
  }
};

export const getWeeklyQuests = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.user_id;
    
    const [quests]: any = await pool.execute(
      `SELECT 
        uaq.*,
        qt.quest_title,
        qt.base_xp,
        qt.difficulty,
        qt.related_stat
      FROM user_active_quests uaq
      LEFT JOIN quest_templates qt ON uaq.quest_template_id = qt.quest_template_id
      WHERE uaq.user_id = ?
      AND uaq.quest_type = 'weekly'
      AND uaq.expires_at > NOW()`,
      [userId]
    );
    
    res.json({ quests });
  } catch (error: any) {
    console.error('Get weekly quests error:', error);
    res.status(500).json({ error: 'Failed to fetch weekly quests' });
  }
};

export const generateDailyQuests = async (req: AuthRequest, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const userId = req.user?.user_id;
    
    // Get user's field of interest
    const [userProfile]: any = await connection.execute(
      'SELECT field_of_interest FROM adventurer_profiles WHERE user_id = ?',
      [userId]
    );
    
    if (userProfile.length === 0) {
      await connection.rollback();
      return res.status(404).json({ error: 'User profile not found' });
    }
    
    const fieldOfInterest = userProfile[0].field_of_interest;
    
    // Clear existing active daily quests
    await connection.execute(
      'DELETE FROM user_active_quests WHERE user_id = ? AND quest_type = "daily"',
      [userId]
    );
    
    // 🎯 STEP 1: Get all available quests (already randomized by database)
    const [templates]: any = await connection.execute(
      `SELECT * FROM quest_templates 
       WHERE field_name = ? AND quest_type = 'daily' AND is_active = 1 
       ORDER BY RAND()`,
      [fieldOfInterest]
    );
    
    console.log(`Found ${templates.length} quest templates for ${fieldOfInterest}`);
    
    // 🎯 STEP 2: Apply additional randomization with JavaScript
    const shuffledTemplates = shuffleArray(templates as QuestTemplate[]);
    
    // 🎯 STEP 3: Select unique quests with advanced checking
    const selectedQuests: QuestTemplate[] = [];
    const usedQuestIds = new Set<number>();
    const usedQuestTitles = new Set<string>();
    
    for (const template of shuffledTemplates) {
      if (selectedQuests.length >= 8) break;
      
      // Check ID uniqueness
      if (usedQuestIds.has(template.quest_template_id)) continue;
      
      // Check title uniqueness (with similarity checking)
      if (!isQuestUnique(template.quest_title, usedQuestTitles)) continue;
      
      // Quest is unique - add it!
      selectedQuests.push(template);
      usedQuestIds.add(template.quest_template_id);
      usedQuestTitles.add(template.quest_title.toLowerCase().trim());
      
      console.log(`✅ Selected unique quest: "${template.quest_title}"`);
    }
    
    // 🎯 STEP 4: If we need more quests, get from other fields
    if (selectedQuests.length < 8) {
      console.log(`Need ${8 - selectedQuests.length} more quests from other fields`);
      
      const [backupTemplates]: any = await connection.execute(
        `SELECT * FROM quest_templates 
         WHERE quest_type = 'daily' AND is_active = 1 
         AND field_name != ?
         ORDER BY RAND() 
         LIMIT ?`,
        [fieldOfInterest, 20] // Get more than needed to ensure uniqueness
      );
      
      const shuffledBackups = shuffleArray(backupTemplates as QuestTemplate[]);
      
      for (const template of shuffledBackups) {
        if (selectedQuests.length >= 8) break;
        
        if (!usedQuestIds.has(template.quest_template_id) && 
            isQuestUnique(template.quest_title, usedQuestTitles)) {
          
          selectedQuests.push(template);
          usedQuestIds.add(template.quest_template_id);
          usedQuestTitles.add(template.quest_title.toLowerCase().trim());
          
          console.log(`✅ Added backup quest: "${template.quest_title}" from ${template.field_name}`);
        }
      }
    }
    
    // 🎯 STEP 5: Final randomization of selected quests
    const finalRandomQuests = shuffleArray(selectedQuests).slice(0, 8);
    
    // 🎯 STEP 6: Insert the random unique quests
    for (const template of finalRandomQuests) {
      await connection.execute(
        `INSERT INTO user_active_quests 
         (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
         VALUES (?, ?, 'daily', CURDATE(), DATE_ADD(NOW(), INTERVAL 1 DAY))`,
        [userId, template.quest_template_id]
      );
    }
    
    await connection.commit();
    
    // Fetch and return the results
    const [newQuests]: any = await connection.execute(
      `SELECT 
        uaq.*,
        COALESCE(qt.quest_title, 
          CASE ROW_NUMBER() OVER (ORDER BY uaq.active_quest_id)
            WHEN 1 THEN 'Morning Routine'
            WHEN 2 THEN 'Study/Practice for 30 minutes'
            WHEN 3 THEN 'Physical Exercise'
            WHEN 4 THEN 'Skill Development'
            WHEN 5 THEN 'Healthy Meal Planning'
            WHEN 6 THEN 'Goal Review & Planning'
            WHEN 7 THEN 'Creative Activity'
            WHEN 8 THEN 'Evening Reflection'
          END
        ) as quest_title,
        COALESCE(qt.quest_description, 'Complete this daily quest to gain XP') as quest_description,
        COALESCE(qt.base_xp, 
          CASE ROW_NUMBER() OVER (ORDER BY uaq.active_quest_id)
            WHEN 1 THEN 25
            WHEN 2 THEN 35
            WHEN 3 THEN 30
            WHEN 4 THEN 40
            WHEN 5 THEN 20
            WHEN 6 THEN 25
            WHEN 7 THEN 30
            WHEN 8 THEN 20
          END
        ) as base_xp,
        COALESCE(qt.difficulty, 'medium') as difficulty,
        COALESCE(qt.related_stat, 'Strength') as related_stat
      FROM user_active_quests uaq
      LEFT JOIN quest_templates qt ON uaq.quest_template_id = qt.quest_template_id
      WHERE uaq.user_id = ? AND uaq.quest_type = 'daily'
      ORDER BY RAND()`, // One final randomization of the display order
      [userId]
    );
    
    console.log(`🎯 SUCCESS: Generated ${newQuests.length} unique random daily quests`);
    
    res.json({ 
      message: 'Random unique daily quests generated successfully!', 
      quests: newQuests,
      count: newQuests.length,
      fieldOfInterest: fieldOfInterest,
      uniqueCount: new Set(newQuests.map((q: any) => q.quest_title)).size,
      randomSeed: Date.now() // For debugging randomness
    });
    
  } catch (error: any) {
    await connection.rollback();
    console.error('Generate daily quests error:', error);
    res.status(500).json({ error: 'Failed to generate daily quests' });
  } finally {
    connection.release();
  }
};
export const generateWeeklyQuests = async (req: AuthRequest, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const userId = req.user?.user_id;
    
    // Get user's field of interest
    const [userProfile]: any = await connection.execute(
      'SELECT field_of_interest FROM adventurer_profiles WHERE user_id = ?',
      [userId]
    );
    
    if (userProfile.length === 0) {
      await connection.rollback();
      return res.status(404).json({ error: 'User profile not found' });
    }
    
    const fieldOfInterest = userProfile[0].field_of_interest;
    
    // Clear existing active weekly quests for this user
    await connection.execute(
      'DELETE FROM user_active_quests WHERE user_id = ? AND quest_type = "weekly"',
      [userId]
    );
    
    // Get available weekly quest templates
    const [templates]: any = await connection.execute(
      `SELECT * FROM quest_templates 
       WHERE field_name = ? AND quest_type = 'weekly' AND is_active = 1 
       ORDER BY RAND() 
       LIMIT 3`,
      [fieldOfInterest]
    );
    
    // If no specific templates found, create default weekly quests
    if (templates.length === 0) {
      const defaultWeeklyQuests = [
        { title: 'Complete 5 Daily Quests', xp: 200, difficulty: 'medium' },
        { title: 'Weekly Skill Master Challenge', xp: 300, difficulty: 'hard' },
        { title: 'Consistency Champion', xp: 250, difficulty: 'medium' }
      ];
      
      for (const quest of defaultWeeklyQuests) {
        await connection.execute(
          `INSERT INTO user_active_quests 
           (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
           VALUES (?, NULL, 'weekly', CURDATE(), DATE_ADD(NOW(), INTERVAL 7 DAY))`,
          [userId]
        );
      }
    } else {
      // Assign quests from templates
      for (const template of templates) {
        await connection.execute(
          `INSERT INTO user_active_quests 
           (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
           VALUES (?, ?, 'weekly', CURDATE(), DATE_ADD(NOW(), INTERVAL 7 DAY))`,
          [userId, template.quest_template_id]
        );
      }
    }
    
    await connection.commit();
    
    // Fetch the newly created weekly quests
    const [newQuests]: any = await connection.execute(
      `SELECT 
        uaq.*,
        COALESCE(qt.quest_title, 
          CASE ROW_NUMBER() OVER (ORDER BY uaq.active_quest_id)
            WHEN 1 THEN 'Complete 5 Daily Quests'
            WHEN 2 THEN 'Weekly Skill Master Challenge'
            WHEN 3 THEN 'Consistency Champion'
          END
        ) as quest_title,
        COALESCE(qt.quest_description, 'Complete this weekly challenge to gain XP') as quest_description,
        COALESCE(qt.base_xp, 
          CASE ROW_NUMBER() OVER (ORDER BY uaq.active_quest_id)
            WHEN 1 THEN 200
            WHEN 2 THEN 300
            WHEN 3 THEN 250
          END
        ) as base_xp,
        COALESCE(qt.difficulty, 'medium') as difficulty,
        COALESCE(qt.related_stat, 'Strength') as related_stat
      FROM user_active_quests uaq
      LEFT JOIN quest_templates qt ON uaq.quest_template_id = qt.quest_template_id
      WHERE uaq.user_id = ? AND uaq.quest_type = 'weekly'`,
      [userId]
    );
    
    res.json({ 
      message: 'Weekly quests generated successfully', 
      quests: newQuests 
    });
    
  } catch (error: any) {
    await connection.rollback();
    console.error('Generate weekly quests error:', error);
    res.status(500).json({ error: 'Failed to generate weekly quests' });
  } finally {
    connection.release();
  }
};

export const completeQuest = async (req: AuthRequest, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const userId = req.user?.user_id;
    const { quest_id } = req.params;
    
    // Check quest exists and get details
    const [questCheck]: any = await connection.execute(
      `SELECT uaq.*, 
        COALESCE(qt.base_xp, 
          CASE uaq.quest_type
            WHEN 'daily' THEN 30
            WHEN 'weekly' THEN 200
            ELSE 50
          END
        ) as xp_reward,
        COALESCE(qt.related_stat, 'Strength') as related_stat
       FROM user_active_quests uaq
       LEFT JOIN quest_templates qt ON uaq.quest_template_id = qt.quest_template_id
       WHERE uaq.active_quest_id = ? AND uaq.user_id = ? AND uaq.is_completed = FALSE`,
      [quest_id, userId]
    );
    
    if (questCheck.length === 0) {
      await connection.rollback();
      return res.status(404).json({ error: 'Quest not found or already completed' });
    }
    
    const quest = questCheck[0];
    const xpGained = quest.xp_reward;
    
    // Mark quest as completed
    await connection.execute(
      'UPDATE user_active_quests SET is_completed = TRUE, completed_at = NOW() WHERE active_quest_id = ?',
      [quest_id]
    );
    
    // Add to completion history
    await connection.execute(
      'INSERT INTO quest_completion_history (user_id, quest_template_id, quest_type, xp_earned) VALUES (?, ?, ?, ?)',
      [userId, quest.quest_template_id, quest.quest_type, xpGained]
    );
    
    // *** NEW: UPDATE STREAK BEFORE UPDATING PROFILE ***
    const streakUpdate = await updateUserStreak(connection, userId, quest.quest_type, xpGained);
    
    // Update user profile with XP
    const [currentProfile]: any = await connection.execute(
      'SELECT * FROM adventurer_profiles WHERE user_id = ?',
      [userId]
    );
    
    if (currentProfile.length > 0) {
      const profile = currentProfile[0];
      const newTotalExp = profile.total_exp + xpGained;
      let newCurrentExp = profile.current_exp + xpGained;
      let newLevel = profile.current_level;
      let expToNext = profile.exp_to_next_level;
      let leveledUp = false;
      
      // Check for level up
      while (newCurrentExp >= expToNext) {
        newCurrentExp -= expToNext;
        newLevel++;
        expToNext = Math.floor(100 * Math.pow(1.5, newLevel - 1));
        leveledUp = true;
      }
      
      // Update profile (streak already updated in updateUserStreak)
      await connection.execute(
        `UPDATE adventurer_profiles 
         SET total_exp = ?, current_exp = ?, current_level = ?, exp_to_next_level = ?
         WHERE user_id = ?`,
        [newTotalExp, newCurrentExp, newLevel, expToNext, userId]
      );
      
      // If leveled up, add to progression history
      if (leveledUp) {
        await connection.execute(
          'INSERT INTO level_progression (user_id, old_level, new_level, total_exp_at_levelup) VALUES (?, ?, ?, ?)',
          [userId, profile.current_level, newLevel, newTotalExp]
        );
      }
      
      // Update stats if quest has related stat
      if (quest.related_stat) {
        await connection.execute(
          `UPDATE user_stats 
           SET current_value = LEAST(current_value + 1, max_value) 
           WHERE user_id = ? AND stat_name = ?`,
          [userId, quest.related_stat]
        );
      }

      // Check achievements after quest completion
      const newAchievements = await checkAchievementsInternal(connection, userId, newLevel, newTotalExp);
      
      await connection.commit();
      
      res.json({ 
        message: 'Quest completed successfully',
        xp_gained: xpGained,
        leveledUp,
        newLevel: leveledUp ? newLevel : profile.current_level,
        totalExp: newTotalExp,
        newAchievements: newAchievements || [],
        streakInfo: streakUpdate ? {
          currentStreak: streakUpdate.newStreakDays,
          streakBroken: streakUpdate.streakBroken,
          isNewRecord: streakUpdate.isNewRecord
        } : null
      });
      
    } else {
      await connection.rollback();
      res.status(404).json({ error: 'Profile not found' });
    }
    
  } catch (error: any) {
    await connection.rollback();
    console.error('Complete quest error:', error);
    res.status(500).json({ error: 'Failed to complete quest' });
  } finally {
    connection.release();
  }
};

// *** NEW: INTERNAL ACHIEVEMENT CHECKING FUNCTION ***
const checkAchievementsInternal = async (connection: any, userId: number, currentLevel: number, currentTotalExp: number) => {
  try {
    const newAchievements = [];
    
    // Get current profile for streak info
    const [profile]: any = await connection.execute(
      'SELECT * FROM adventurer_profiles WHERE user_id = ?',
      [userId]
    );
    
    if (profile.length === 0) {
      return newAchievements;
    }
    
    const currentProfile = profile[0];
    
    // Count completed quests
    const [questCount]: any = await connection.execute(
      'SELECT COUNT(*) as count FROM quest_completion_history WHERE user_id = ?',
      [userId]
    );
    
    const completedQuests = questCount[0].count;
    
    // Check various achievement conditions
    const achievementChecks = [
      { id: 1, name: 'First Steps', condition: completedQuests >= 1 },
      { id: 2, name: 'Week Warrior', condition: currentProfile.streak_days >= 7 },
      { id: 3, name: 'Level 5 Hunter', condition: currentLevel >= 5 },
      { id: 4, name: 'Level 10 Fighter', condition: currentLevel >= 10 },
      { id: 5, name: 'Quest Master', condition: completedQuests >= 50 },
      { id: 6, name: 'Dedication', condition: currentProfile.streak_days >= 30 },
      { id: 7, name: 'Power Surge', condition: currentTotalExp >= 1000 },
      { id: 8, name: 'Elite Hunter', condition: currentLevel >= 20 },
      { id: 10, name: 'Shadow Monarch', condition: currentLevel >= 50 }
    ];
    
    // Check stat-based achievements
    const [stats]: any = await connection.execute(
      'SELECT * FROM user_stats WHERE user_id = ? AND current_value >= 100',
      [userId]
    );
    
    if (stats.length > 0) {
      achievementChecks.push({ id: 9, name: 'Strength Master', condition: true });
    }
    
    // Check and award achievements
    for (const check of achievementChecks) {
      if (check.condition) {
        // Check if already earned
        const [existing]: any = await connection.execute(
          'SELECT * FROM user_achievements WHERE user_id = ? AND achievement_id = ?',
          [userId, check.id]
        );
        
        if (existing.length === 0) {
          // Award achievement
          await connection.execute(
            'INSERT INTO user_achievements (user_id, achievement_id, earned_at) VALUES (?, ?, NOW())',
            [userId, check.id]
          );
          
          // Add to new achievements list
          newAchievements.push({
            achievement_id: check.id,
            achievement_name: check.name
          });
          
          // Create notification
          await connection.execute(
            `INSERT INTO notifications 
             (user_id, notification_type, title, message, expires_at) 
             VALUES (?, 'achievement', ?, ?, DATE_ADD(NOW(), INTERVAL 30 DAY))`,
            [userId, `Achievement Unlocked: ${check.name}!`, `Congratulations! You have earned the ${check.name} achievement!`]
          );
        }
      }
    }
    
    return newAchievements;
    
  } catch (error) {
    console.error('Internal achievement check error:', error);
    return [];
  }
};

// Add this function to your questController.ts

export const initializeQuestSystem = async (req: AuthRequest, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const userId = req.user?.user_id;
    
    // Check if user already has quests
    const [existingQuests]: any = await connection.execute(
      'SELECT COUNT(*) as count FROM user_active_quests WHERE user_id = ?',
      [userId]
    );
    
    if (existingQuests[0].count > 0) {
      await connection.rollback();
      return res.json({ message: 'Quest system already initialized' });
    }
    
    // Get user's field of interest
    const [userProfile]: any = await connection.execute(
      'SELECT field_of_interest FROM adventurer_profiles WHERE user_id = ?',
      [userId]
    );
    
    if (userProfile.length === 0) {
      await connection.rollback();
      return res.status(404).json({ error: 'User profile not found' });
    }
    
    const fieldOfInterest = userProfile[0].field_of_interest;
    
    // Generate initial daily quests
    const [dailyTemplates]: any = await connection.execute(
      `SELECT * FROM quest_templates 
       WHERE field_name = ? AND quest_type = 'daily' AND is_active = 1 
       ORDER BY RAND() 
       LIMIT 8`,
      [fieldOfInterest]
    );
    
    // Generate initial weekly quests
    const [weeklyTemplates]: any = await connection.execute(
      `SELECT * FROM quest_templates 
       WHERE field_name = ? AND quest_type = 'weekly' AND is_active = 1 
       ORDER BY RAND() 
       LIMIT 3`,
      [fieldOfInterest]
    );
    
    // Insert daily quests
    for (const template of dailyTemplates) {
      await connection.execute(
        `INSERT INTO user_active_quests 
         (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
         VALUES (?, ?, 'daily', CURDATE(), DATE_ADD(NOW(), INTERVAL 1 DAY))`,
        [userId, template.quest_template_id]
      );
    }
    
    // Insert weekly quests
    for (const template of weeklyTemplates) {
      await connection.execute(
        `INSERT INTO user_active_quests 
         (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
         VALUES (?, ?, 'weekly', CURDATE(), DATE_ADD(NOW(), INTERVAL 7 DAY))`,
        [userId, template.quest_template_id]
      );
    }
    
    // If no templates found, create default quests
    if (dailyTemplates.length === 0) {
      const defaultQuests = [
        'Morning Routine', 'Study/Practice Session', 'Physical Exercise', 'Skill Development',
        'Healthy Meal Planning', 'Goal Review', 'Creative Activity', 'Evening Reflection'
      ];
      
      for (const questTitle of defaultQuests) {
        await connection.execute(
          `INSERT INTO user_active_quests 
           (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
           VALUES (?, NULL, 'daily', CURDATE(), DATE_ADD(NOW(), INTERVAL 1 DAY))`,
          [userId]
        );
      }
    }
    
    if (weeklyTemplates.length === 0) {
      const defaultWeeklyQuests = [
        'Complete 5 Daily Quests', 'Weekly Challenge', 'Consistency Goal'
      ];
      
      for (const questTitle of defaultWeeklyQuests) {
        await connection.execute(
          `INSERT INTO user_active_quests 
           (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
           VALUES (?, NULL, 'weekly', CURDATE(), DATE_ADD(NOW(), INTERVAL 7 DAY))`,
          [userId]
        );
      }
    }
    
    await connection.commit();
    
    res.json({ 
      message: 'Quest system initialized successfully',
      dailyQuests: dailyTemplates.length || 8,
      weeklyQuests: weeklyTemplates.length || 3
    });
    
  } catch (error: any) {
    await connection.rollback();
    console.error('Initialize quest system error:', error);
    res.status(500).json({ error: 'Failed to initialize quest system' });
  } finally {
    connection.release();
  }
};
const updateUserStreak = async (connection: any, userId: number, questType: string, xpEarned: number) => {
  try {
    const today = new Date().toISOString().split('T')[0]; // Get today's date in YYYY-MM-DD format
    
    // Get current profile info
    const [currentProfile]: any = await connection.execute(
      'SELECT * FROM adventurer_profiles WHERE user_id = ?',
      [userId]
    );
    
    if (currentProfile.length === 0) {
      return;
    }
    
    const profile = currentProfile[0];
    const lastActivityDate = profile.last_activity_date;
    
    // Check if user already has a checkin for today
    const [existingCheckin]: any = await connection.execute(
      'SELECT * FROM daily_checkins WHERE user_id = ? AND checkin_date = ?',
      [userId, today]
    );
    
    if (existingCheckin.length === 0) {
      // No checkin for today, create one
      await connection.execute(
        `INSERT INTO daily_checkins (user_id, checkin_date, quests_completed, total_xp_earned) 
         VALUES (?, ?, 1, ?)`,
        [userId, today, xpEarned]
      );
    } else {
      // Update existing checkin
      await connection.execute(
        `UPDATE daily_checkins 
         SET quests_completed = quests_completed + 1, 
             total_xp_earned = total_xp_earned + ?
         WHERE user_id = ? AND checkin_date = ?`,
        [xpEarned, userId, today]
      );
    }
    
    // Calculate streak
    let newStreakDays = 1;
    let streakBroken = false;
    
    if (lastActivityDate) {
      const lastActivity = new Date(lastActivityDate);
      const todayDate = new Date(today);
      const diffTime = todayDate.getTime() - lastActivity.getTime();
      const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
      
      if (diffDays === 0) {
        // Same day, don't change streak
        newStreakDays = profile.streak_days;
      } else if (diffDays === 1) {
        // Consecutive day, increment streak
        newStreakDays = profile.streak_days + 1;
      } else {
        // Gap in days, reset streak
        newStreakDays = 1;
        streakBroken = true;
      }
    }
    
    // Update longest streak if current streak is longer
    const newLongestStreak = Math.max(profile.longest_streak || 0, newStreakDays);
    
    // Update adventurer profile with new streak info
    await connection.execute(
      `UPDATE adventurer_profiles 
       SET streak_days = ?, 
           longest_streak = ?, 
           last_activity_date = ?
       WHERE user_id = ?`,
      [newStreakDays, newLongestStreak, today, userId]
    );
    
    // Create streak milestone notifications
    if (newStreakDays === 7) {
      await connection.execute(
        `INSERT INTO notifications 
         (user_id, notification_type, title, message, expires_at) 
         VALUES (?, 'streak_milestone', '7-Day Streak! 🔥', 'Congratulations on maintaining a week-long streak!', DATE_ADD(NOW(), INTERVAL 30 DAY))`,
        [userId]
      );
    } else if (newStreakDays === 30) {
      await connection.execute(
        `INSERT INTO notifications 
         (user_id, notification_type, title, message, expires_at) 
         VALUES (?, 'streak_milestone', '30-Day Streak! 💎', 'Amazing! You have maintained a month-long streak!', DATE_ADD(NOW(), INTERVAL 30 DAY))`,
        [userId]
      );
    } else if (newStreakDays % 50 === 0 && newStreakDays > 30) {
      await connection.execute(
        `INSERT INTO notifications 
         (user_id, notification_type, title, message, expires_at) 
         VALUES (?, 'streak_milestone', ?, 'Incredible dedication! You are on fire!', DATE_ADD(NOW(), INTERVAL 30 DAY))`,
        [userId, `${newStreakDays}-Day Streak! 🚀`]
      );
    }
    
    // Warn about streak being at risk (if last activity was yesterday)
    if (streakBroken && profile.streak_days > 7) {
      await connection.execute(
        `INSERT INTO notifications 
         (user_id, notification_type, title, message, expires_at) 
         VALUES (?, 'streak_warning', 'Streak Reset', 'Your streak has been reset. Start building it again!', DATE_ADD(NOW(), INTERVAL 7 DAY))`,
        [userId]
      );
    }
    
    return {
      newStreakDays,
      streakBroken,
      isNewRecord: newStreakDays > (profile.longest_streak || 0)
    };
    
  } catch (error) {
    console.error('Streak update error:', error);
    return null;
  }
};

// Add these functions to your questController.ts

/**
 * Automatic Quest Expiration and Renewal System
 * This runs daily to expire old quests and generate fresh ones
 */
export const processQuestExpiration = async (req: AuthRequest, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    console.log('🕒 Starting automatic quest expiration process...');
    
    // Step 1: Mark all expired daily quests as expired (not completed)
    const [expiredDaily]: any = await connection.execute(
      `UPDATE user_active_quests 
       SET is_completed = FALSE, 
           expires_at = NOW() - INTERVAL 1 SECOND
       WHERE quest_type = 'daily' 
       AND expires_at < NOW() 
       AND is_completed = FALSE`
    );
    
    console.log(`⏰ Expired ${expiredDaily.affectedRows} uncompleted daily quests`);
    
    // Step 2: Get all users who need new daily quests
    const [usersNeedingQuests]: any = await connection.execute(
      `SELECT DISTINCT u.user_id, ap.field_of_interest, u.email
       FROM users u
       JOIN adventurer_profiles ap ON u.user_id = ap.user_id
       LEFT JOIN user_active_quests uaq ON u.user_id = uaq.user_id 
         AND uaq.quest_type = 'daily' 
         AND uaq.expires_at > NOW()
       WHERE u.user_type = 'adventurer' 
       AND uaq.user_id IS NULL`
    );
    
    console.log(`👥 Found ${usersNeedingQuests.length} users needing new daily quests`);
    
    let renewedUsers = 0;
    
    // Step 3: Generate fresh daily quests for each user
    for (const user of usersNeedingQuests) {
      try {
        const userId = user.user_id;
        const fieldOfInterest = user.field_of_interest;
        
        // Generate new unique daily quests using our improved algorithm
        const newQuests = await generateUniqueQuestsForUser(connection, userId, fieldOfInterest);
        
        if (newQuests.length > 0) {
          console.log(`✅ Renewed ${newQuests.length} daily quests for user ${user.email}`);
          renewedUsers++;
        }
        
      } catch (userError) {
        console.error(`❌ Error renewing quests for user ${user.email}:`, userError);
      }
    }
    
    // Step 4: Clean up very old expired quests (optional - keeps database clean)
    const [cleanedUp]: any = await connection.execute(
      `DELETE FROM user_active_quests 
       WHERE expires_at < NOW() - INTERVAL 7 DAY 
       AND is_completed = FALSE`
    );
    
    console.log(`🧹 Cleaned up ${cleanedUp.affectedRows} old expired quests`);
    
    await connection.commit();
    
    const summary = {
      message: 'Quest expiration process completed successfully',
      expiredQuests: expiredDaily.affectedRows,
      usersRenewed: renewedUsers,
      totalUsers: usersNeedingQuests.length,
      oldQuestsCleaned: cleanedUp.affectedRows,
      processTime: new Date().toISOString()
    };
    
    console.log('🎯 Quest expiration summary:', summary);
    
    res.json(summary);
    
  } catch (error: any) {
    await connection.rollback();
    console.error('Quest expiration process error:', error);
    res.status(500).json({ error: 'Failed to process quest expiration' });
  } finally {
    connection.release();
  }
};

/**
 * Helper function to generate unique quests for a specific user
 * Extracted logic for reuse in expiration process
 */
const generateUniqueQuestsForUser = async (connection: any, userId: number, fieldOfInterest: string) => {
  try {
    // Get available quest templates for user's field
    const [templates]: any = await connection.execute(
      `SELECT * FROM quest_templates 
       WHERE field_name = ? AND quest_type = 'daily' AND is_active = 1 
       ORDER BY RAND()`,
      [fieldOfInterest]
    );
    
    // Apply uniqueness selection logic
    const shuffledTemplates = shuffleArray(templates as QuestTemplate[]);
    const selectedQuests: QuestTemplate[] = [];
    const usedQuestIds = new Set<number>();
    const usedQuestTitles = new Set<string>();
    
    for (const template of shuffledTemplates) {
      if (selectedQuests.length >= 8) break;
      
      if (usedQuestIds.has(template.quest_template_id)) continue;
      if (!isQuestUnique(template.quest_title, usedQuestTitles)) continue;
      
      selectedQuests.push(template);
      usedQuestIds.add(template.quest_template_id);
      usedQuestTitles.add(template.quest_title.toLowerCase().trim());
    }
    
    // Get backup quests from other fields if needed
    if (selectedQuests.length < 8) {
      const [backupTemplates]: any = await connection.execute(
        `SELECT * FROM quest_templates 
         WHERE quest_type = 'daily' AND is_active = 1 
         AND field_name != ?
         ORDER BY RAND() 
         LIMIT ?`,
        [fieldOfInterest, 20]
      );
      
      const shuffledBackups = shuffleArray(backupTemplates as QuestTemplate[]);
      
      for (const template of shuffledBackups) {
        if (selectedQuests.length >= 8) break;
        
        if (!usedQuestIds.has(template.quest_template_id) && 
            isQuestUnique(template.quest_title, usedQuestTitles)) {
          
          selectedQuests.push(template);
          usedQuestIds.add(template.quest_template_id);
          usedQuestTitles.add(template.quest_title.toLowerCase().trim());
        }
      }
    }
    
    // Insert the new unique quests
    const finalQuests = shuffleArray(selectedQuests).slice(0, 8);
    
    for (const template of finalQuests) {
      await connection.execute(
        `INSERT INTO user_active_quests 
         (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
         VALUES (?, ?, 'daily', CURDATE(), DATE_ADD(NOW(), INTERVAL 1 DAY))`,
        [userId, template.quest_template_id]
      );
    }
    
    return finalQuests;
    
  } catch (error) {
    console.error('Generate unique quests for user error:', error);
    return [];
  }
};

/**
 * Manual trigger for quest expiration (for testing)
 * In production, this should be called automatically via cron job
 */
export const triggerQuestReset = async (req: AuthRequest, res: Response) => {
  // This is the same as processQuestExpiration but with different messaging
  return processQuestExpiration(req, res);
};

/**
 * Check if current user needs quest renewal
 * Useful for frontend to know when to show "generate new quests" button
 */
export const checkQuestStatus = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.user_id;
    
    const [activeQuests]: any = await pool.execute(
      `SELECT COUNT(*) as active_count
       FROM user_active_quests 
       WHERE user_id = ? 
       AND quest_type = 'daily' 
       AND expires_at > NOW() 
       AND is_completed = FALSE`,
      [userId]
    );
    
    const [expiredQuests]: any = await pool.execute(
      `SELECT COUNT(*) as expired_count
       FROM user_active_quests 
       WHERE user_id = ? 
       AND quest_type = 'daily' 
       AND expires_at < NOW() 
       AND is_completed = FALSE`,
      [userId]
    );
    
    const hasActiveQuests = activeQuests[0].active_count > 0;
    const hasExpiredQuests = expiredQuests[0].expired_count > 0;
    
    res.json({
      hasActiveQuests,
      hasExpiredQuests,
      activeQuestCount: activeQuests[0].active_count,
      expiredQuestCount: expiredQuests[0].expired_count,
      needsRenewal: !hasActiveQuests || hasExpiredQuests,
      canGenerateNew: !hasActiveQuests
    });
    
  } catch (error: any) {
    console.error('Check quest status error:', error);
    res.status(500).json({ error: 'Failed to check quest status' });
  }
};






src/controller/statsController.ts
(empty)




src/controller/userController.ts
// src/controller/userController.ts
import { Request, Response } from 'express';
import { AuthRequest } from '../middleware/auth';
import pool from '../config/database';
const fs = require('fs').promises;
const path = require('path');

export const getUserProfile = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.user_id;
    const userType = req.user?.user_type;
    
    // Get user data
    const [users]: any = await pool.execute(
      'SELECT user_id, email, username, user_type, profile_photo_url FROM users WHERE user_id = ?',
      [userId]
    );
    
    if (users.length === 0) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Get profile
    let profile = null;
    let stats = null;
    
    if (userType === 'adventurer') {
      const [profiles]: any = await pool.execute(
        'SELECT * FROM adventurer_profiles WHERE user_id = ?',
        [userId]
      );
      profile = profiles[0];
      
      // Initialize profile if missing fields
      if (profile && (!profile.exp_to_next_level || !profile.current_exp)) {
        await pool.execute(
          `UPDATE adventurer_profiles 
           SET exp_to_next_level = COALESCE(exp_to_next_level, 100),
               current_exp = COALESCE(current_exp, 0),
               streak_days = COALESCE(streak_days, 0)
           WHERE user_id = ?`,
          [userId]
        );
        
        // Fetch updated profile
        const [updatedProfiles]: any = await pool.execute(
          'SELECT * FROM adventurer_profiles WHERE user_id = ?',
          [userId]
        );
        profile = updatedProfiles[0];
      }
      
      const [userStats]: any = await pool.execute(
        'SELECT * FROM user_stats WHERE user_id = ? ORDER BY stat_name',
        [userId]
      );
      stats = userStats;
      
      // Initialize stats if empty
      if (stats.length === 0) {
        await initializeUserStatsInternal(userId, profile.field_of_interest);
        const [newStats]: any = await pool.execute(
          'SELECT * FROM user_stats WHERE user_id = ? ORDER BY stat_name',
          [userId]
        );
        stats = newStats;
      }
    } else {
      const [profiles]: any = await pool.execute(
        'SELECT * FROM coach_profiles WHERE user_id = ?',
        [userId]
      );
      profile = profiles[0];
    }
    
    res.json({
      user: users[0],
      profile,
      stats
    });
    
  } catch (error: any) {
    console.error('Get profile error:', error);
    res.status(500).json({ error: 'Failed to fetch profile' });
  }
};

export const getUserStats = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.user_id;
    
    let [stats]: any = await pool.execute(
      'SELECT * FROM user_stats WHERE user_id = ? ORDER BY stat_name',
      [userId]
    );
    
    // Initialize stats if they don't exist
    if (stats.length === 0) {
      const [profile]: any = await pool.execute(
        'SELECT field_of_interest FROM adventurer_profiles WHERE user_id = ?',
        [userId]
      );
      
      if (profile.length > 0) {
        await initializeUserStatsInternal(userId, profile[0].field_of_interest);
        
        [stats] = await pool.execute(
          'SELECT * FROM user_stats WHERE user_id = ? ORDER BY stat_name',
          [userId]
        );
      }
    }
    
    res.json({ stats });
  } catch (error: any) {
    console.error('Get stats error:', error);
    res.status(500).json({ error: 'Failed to fetch stats' });
  }
};

// Internal function to initialize stats
async function initializeUserStatsInternal(userId: number, fieldOfInterest: string) {
  const connection = await pool.getConnection();
  
  try {
    // Check if stats already exist
    const [existing]: any = await connection.execute(
      'SELECT COUNT(*) as count FROM user_stats WHERE user_id = ?',
      [userId]
    );
    
    if (existing[0].count > 0) {
      return; // Stats already exist
    }
    
    // Try to get stats from template first
    const [templateStats]: any = await connection.execute(
      `SELECT stat_name, stat_icon, initial_value, max_value 
       FROM stats_template 
       WHERE field_name = ? 
       ORDER BY stat_order`,
      [fieldOfInterest]
    );
    
    let statsToInsert = [];
    
    if (templateStats.length > 0) {
      // Use template stats
      statsToInsert = templateStats.map((stat: any) => ({
        name: stat.stat_name,
        icon: stat.stat_icon,
        initial: stat.initial_value || 10,
        max: stat.max_value || 100
      }));
    } else {
      // Use default stats
      statsToInsert = [
        { name: 'Strength', icon: '💪', initial: 10, max: 100 },
        { name: 'Intelligence', icon: '🧠', initial: 10, max: 100 },
        { name: 'Agility', icon: '⚡', initial: 10, max: 100 },
        { name: 'Stamina', icon: '🏃', initial: 10, max: 100 },
        { name: 'Wisdom', icon: '📚', initial: 10, max: 100 },
        { name: 'Charisma', icon: '✨', initial: 10, max: 100 }
      ];
    }
    
    // Insert stats
    for (const stat of statsToInsert) {
      await connection.execute(
        'INSERT INTO user_stats (user_id, stat_name, stat_icon, current_value, max_value) VALUES (?, ?, ?, ?, ?)',
        [userId, stat.name, stat.icon, stat.initial, stat.max]
      );
    }
    
  } catch (error) {
    console.error('Error initializing stats:', error);
    throw error;
  } finally {
    connection.release();
  }
}

export const initializeUserStats = async (req: AuthRequest, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const userId = req.user?.user_id;
    
    // Get user's field of interest
    const [profile]: any = await connection.execute(
      'SELECT field_of_interest FROM adventurer_profiles WHERE user_id = ?',
      [userId]
    );
    
    if (profile.length === 0) {
      await connection.rollback();
      return res.status(404).json({ error: 'Profile not found' });
    }
    
    await initializeUserStatsInternal(userId, profile[0].field_of_interest);
    
    await connection.commit();
    
    // Fetch and return the initialized stats
    const [stats]: any = await pool.execute(
      'SELECT * FROM user_stats WHERE user_id = ? ORDER BY stat_name',
      [userId]
    );
    
    res.json({ stats, message: 'Stats initialized successfully' });
    
  } catch (error: any) {
    await connection.rollback();
    console.error('Initialize stats error:', error);
    res.status(500).json({ error: 'Failed to initialize stats' });
  } finally {
    connection.release();
  }
};

export const getAchievements = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.user_id;
    
    // Get earned achievements
    const [earned]: any = await pool.execute(
      `SELECT a.*, ua.earned_at
      FROM user_achievements ua
      JOIN achievements a ON ua.achievement_id = a.achievement_id
      WHERE ua.user_id = ?
      ORDER BY ua.earned_at DESC`,
      [userId]
    );
    
    res.json({ achievements: earned });
  } catch (error: any) {
    console.error('Get achievements error:', error);
    res.status(500).json({ error: 'Failed to fetch achievements' });
  }
};

export const checkAchievements = async (req: AuthRequest, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const userId = req.user?.user_id;
    const { level, totalExp } = req.body;
    
    const newAchievements = [];
    
    // Get current profile and stats
    const [profile]: any = await connection.execute(
      'SELECT * FROM adventurer_profiles WHERE user_id = ?',
      [userId]
    );
    
    if (profile.length === 0) {
      await connection.rollback();
      return res.status(404).json({ error: 'Profile not found' });
    }
    
    const currentProfile = profile[0];
    const currentLevel = level || currentProfile.current_level;
    const currentTotalExp = totalExp || currentProfile.total_exp;
    
    // Count completed quests
    const [questCount]: any = await connection.execute(
      'SELECT COUNT(*) as count FROM quest_completion_history WHERE user_id = ?',
      [userId]
    );
    
    const completedQuests = questCount[0].count;
    
    // Check various achievement conditions
    const achievementChecks = [
      { id: 1, name: 'First Steps', condition: completedQuests >= 1 },
      { id: 2, name: 'Week Warrior', condition: currentProfile.streak_days >= 7 },
      { id: 3, name: 'Level 5 Hunter', condition: currentLevel >= 5 },
      { id: 4, name: 'Level 10 Fighter', condition: currentLevel >= 10 },
      { id: 5, name: 'Quest Master', condition: completedQuests >= 50 },
      { id: 6, name: 'Dedication', condition: currentProfile.streak_days >= 30 },
      { id: 7, name: 'Power Surge', condition: currentTotalExp >= 1000 },
      { id: 8, name: 'Elite Hunter', condition: currentLevel >= 20 },
      { id: 10, name: 'Shadow Monarch', condition: currentLevel >= 50 }
    ];
    
    // Check stat-based achievements
    const [stats]: any = await connection.execute(
      'SELECT * FROM user_stats WHERE user_id = ? AND current_value >= 100',
      [userId]
    );
    
    if (stats.length > 0) {
      achievementChecks.push({ id: 9, name: 'Stat Master', condition: true });
    }
    
    // Check and award achievements
    for (const check of achievementChecks) {
      if (check.condition) {
        // Check if already earned
        const [existing]: any = await connection.execute(
          'SELECT * FROM user_achievements WHERE user_id = ? AND achievement_id = ?',
          [userId, check.id]
        );
        
        if (existing.length === 0) {
          // Award achievement
          await connection.execute(
            'INSERT INTO user_achievements (user_id, achievement_id, earned_at) VALUES (?, ?, NOW())',
            [userId, check.id]
          );
          
          // Add to new achievements list
          newAchievements.push({
            achievement_id: check.id,
            achievement_name: check.name
          });
          
          // Create notification
          await connection.execute(
            `INSERT INTO notifications 
             (user_id, notification_type, title, message, expires_at) 
             VALUES (?, 'achievement', ?, ?, DATE_ADD(NOW(), INTERVAL 30 DAY))`,
            [userId, `Achievement Unlocked: ${check.name}!`, `Congratulations! You've earned the ${check.name} achievement!`]
          );
        }
      }
    }
    
    await connection.commit();
    
    res.json({ newAchievements });
    
  } catch (error: any) {
    await connection.rollback();
    console.error('Check achievements error:', error);
    res.status(500).json({ error: 'Failed to check achievements' });
  } finally {
    connection.release();
  }
};

export const uploadProfilePhoto = async (req: AuthRequest, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const userId = req.user?.user_id;
    const file = req.file;
    
    if (!file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }
    
    // Generate unique filename
    const uniqueName = `${userId}_${Date.now()}${path.extname(file.originalname)}`;
    const newPath = path.join('uploads', 'profiles', uniqueName);
    
    // Move file from temp to profiles folder
    try {
      await fs.rename(file.path, newPath);
    } catch (moveError: any) {
      // If rename fails, try copy and delete
      await fs.copyFile(file.path, newPath);
      await fs.unlink(file.path);
    }
    
    const profilePhotoUrl = `/uploads/profiles/${uniqueName}`;
    
    // Get old photo URL to delete
    const [oldPhoto]: any = await connection.execute(
      'SELECT profile_photo_url FROM users WHERE user_id = ?',
      [userId]
    );
    
    // Update user profile photo
    await connection.execute(
      'UPDATE users SET profile_photo_url = ? WHERE user_id = ?',
      [profilePhotoUrl, userId]
    );
    
    // Log to media_uploads table
    await connection.execute(
      `INSERT INTO media_uploads 
       (user_id, media_type, file_url, file_name, file_size, mime_type) 
       VALUES (?, 'profile_photo', ?, ?, ?, ?)`,
      [userId, profilePhotoUrl, file.originalname, file.size, file.mimetype]
    );
    
    // Delete old photo file if exists
    if (oldPhoto[0]?.profile_photo_url) {
      const oldPath = path.join('uploads', 'profiles', path.basename(oldPhoto[0].profile_photo_url));
      try {
        await fs.unlink(oldPath);
      } catch (err) {
        console.log('Could not delete old photo:', err);
      }
    }
    
    await connection.commit();
    
    res.json({ 
      message: 'Profile photo uploaded successfully',
      profile_photo_url: profilePhotoUrl 
    });
    
  } catch (error: any) {
    await connection.rollback();
    console.error('Upload profile photo error:', error);
    
    // Try to clean up uploaded file
    if (req.file) {
      try {
        await fs.unlink(req.file.path);
      } catch (err) {
        console.log('Could not delete temp file:', err);
      }
    }
    
    res.status(500).json({ error: 'Failed to upload profile photo' });
  } finally {
    connection.release();
  }
};

export const removeProfilePhoto = async (req: AuthRequest, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const userId = req.user?.user_id;
    
    // Get current photo URL
    const [currentPhoto]: any = await connection.execute(
      'SELECT profile_photo_url FROM users WHERE user_id = ?',
      [userId]
    );
    
    if (currentPhoto[0]?.profile_photo_url) {
      // Delete file
      const photoPath = path.join('uploads', 'profiles', path.basename(currentPhoto[0].profile_photo_url));
      try {
        await fs.unlink(photoPath);
      } catch (err) {
        console.log('Could not delete photo file:', err);
      }
    }
    
    // Update database
    await connection.execute(
      'UPDATE users SET profile_photo_url = NULL WHERE user_id = ?',
      [userId]
    );
    
    await connection.commit();
    
    res.json({ message: 'Profile photo removed successfully' });
    
  } catch (error: any) {
    await connection.rollback();
    console.error('Remove profile photo error:', error);
    res.status(500).json({ error: 'Failed to remove profile photo' });
  } finally {
    connection.release();
  }
};

export const getReceivedFeedback = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.user_id;
    
    console.log('=== GET RECEIVED FEEDBACK DEBUG ===');
    console.log('Student User ID:', userId);
    
    if (!userId) {
      return res.status(400).json({ error: 'User ID not found' });
    }
    
    // Enhanced query with detailed coach info
    const [feedback]: any = await pool.execute(`
      SELECT 
        cf.feedback_id,
        cf.coach_user_id,
        cf.student_user_id,
        cf.feedback_type,
        cf.feedback_text,
        cf.rating,
        cf.is_read,
        cf.created_at,
        -- Coach basic info
        u.username as coach_username,
        u.profile_photo_url as coach_photo,
        u.email as coach_email,
        -- Coach profile info
        cp.full_name as coach_full_name,
        cp.bio as coach_bio,
        cp.specialization as coach_specialization,
        -- Formatted dates
        DATE_FORMAT(cf.created_at, '%M %e, %Y at %h:%i %p') as formatted_date,
        -- Time ago calculation
        CASE 
          WHEN TIMESTAMPDIFF(MINUTE, cf.created_at, NOW()) < 60 THEN 
            CONCAT(TIMESTAMPDIFF(MINUTE, cf.created_at, NOW()), ' minutes ago')
          WHEN TIMESTAMPDIFF(HOUR, cf.created_at, NOW()) < 24 THEN 
            CONCAT(TIMESTAMPDIFF(HOUR, cf.created_at, NOW()), ' hours ago')
          WHEN TIMESTAMPDIFF(DAY, cf.created_at, NOW()) < 30 THEN 
            CONCAT(TIMESTAMPDIFF(DAY, cf.created_at, NOW()), ' days ago')
          ELSE 
            DATE_FORMAT(cf.created_at, '%M %e, %Y')
        END as time_ago
        
      FROM coach_feedback cf
      LEFT JOIN users u ON cf.coach_user_id = u.user_id
      LEFT JOIN coach_profiles cp ON cf.coach_user_id = cp.user_id
      WHERE cf.student_user_id = ?
      ORDER BY cf.created_at DESC
      LIMIT 50
    `, [userId]);
    
    console.log(`Found ${feedback.length} feedback messages`);
    
    // Debug each feedback message's coach info
    feedback.forEach((f: any, index: number) => {
      console.log(`\n--- Feedback ${index + 1} Debug ---`);
      console.log('Coach User ID:', f.coach_user_id);
      console.log('Coach Username:', f.coach_username);
      console.log('Coach Full Name:', f.coach_full_name);
      console.log('Coach Photo URL (RAW):', f.coach_photo);
      console.log('Coach Email:', f.coach_email);
      console.log('Message Preview:', f.feedback_text.substring(0, 30) + '...');
    });
    
    // Process feedback with enhanced coach info
    const processedFeedback = feedback.map((f: any) => ({
      ...f,
      coach_name: f.coach_full_name || f.coach_username || 'Your Coach',
      coach_title: f.coach_specialization || 'Life Coach',
      coach_experience: '1+ years experience',
      formatted_date: f.formatted_date || new Date(f.created_at).toLocaleDateString(),
      time_ago: f.time_ago || 'Recently'
    }));
    
    console.log('\n=== PROCESSED FEEDBACK SAMPLE ===');
    if (processedFeedback.length > 0) {
      const sample = processedFeedback[0];
      console.log('Sample processed feedback:');
      console.log('- Coach Name:', sample.coach_name);
      console.log('- Coach Photo URL:', sample.coach_photo);
      console.log('- Coach Title:', sample.coach_title);
      console.log('- Formatted Date:', sample.formatted_date);
    }
    console.log('=================================');
    
    res.json({ 
      feedback: processedFeedback,
      unread_count: processedFeedback.filter((f: any) => !f.is_read).length,
      total_count: processedFeedback.length,
      debug_info: {
        student_id: userId,
        raw_feedback_count: feedback.length,
        processed_feedback_count: processedFeedback.length,
        sample_coach_photo: processedFeedback.length > 0 ? processedFeedback[0].coach_photo : null
      }
    });
    
  } catch (error: any) {
    console.error('=== GET RECEIVED FEEDBACK ERROR ===');
    console.error('Error message:', error.message);
    console.error('Error code:', error.code);
    console.error('SQL State:', error.sqlState);
    console.error('====================================');
    
    res.status(500).json({ 
      error: 'Failed to fetch received feedback',
      details: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
    });
  }
};

export const markFeedbackAsRead = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.user_id;
    const { feedback_id } = req.params;
    
    // Mark specific feedback as read
    await pool.execute(
      'UPDATE coach_feedback SET is_read = TRUE WHERE feedback_id = ? AND student_user_id = ?',
      [feedback_id, userId]
    );
    
    res.json({ message: 'Feedback marked as read' });
    
  } catch (error: any) {
    console.error('Mark feedback as read error:', error);
    res.status(500).json({ error: 'Failed to mark feedback as read' });
  }
};

export const recalculateUserStreak = async (req: AuthRequest, res: Response) => {
  const connection = await pool.getConnection();
  
  try {
    const userId = req.user?.user_id;
    
    // Call the stored procedure to recalculate streak
    await connection.execute('CALL RecalculateUserStreak(?)', [userId]);
    
    // Get updated profile data
    const [profile]: any = await connection.execute(
      'SELECT streak_days, longest_streak, last_activity_date FROM adventurer_profiles WHERE user_id = ?',
      [userId]
    );
    
    res.json({
      message: 'Streak recalculated successfully',
      streakInfo: profile[0] || null
    });
    
  } catch (error: any) {
    console.error('Recalculate streak error:', error);
    res.status(500).json({ error: 'Failed to recalculate streak' });
  } finally {
    connection.release();
  }
};

export const getUserStreakDetails = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.user_id;
    
    // Get streak information
    const [profile]: any = await pool.execute(
      `SELECT 
         streak_days, 
         longest_streak, 
         last_activity_date,
         DATEDIFF(CURDATE(), last_activity_date) as days_since_last_activity
       FROM adventurer_profiles 
       WHERE user_id = ?`,
      [userId]
    );
    
    // Get daily checkins for the last 30 days
    const [checkins]: any = await pool.execute(
      `SELECT 
         checkin_date, 
         quests_completed, 
         total_xp_earned 
       FROM daily_checkins 
       WHERE user_id = ? AND checkin_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
       ORDER BY checkin_date DESC`,
      [userId]
    );
    
    // Calculate streak status
    let streakStatus = 'unknown';
    if (profile[0]) {
      const daysSinceLastActivity = profile[0].days_since_last_activity;
      if (daysSinceLastActivity === 0) streakStatus = 'active';
      else if (daysSinceLastActivity === 1) streakStatus = 'at_risk';
      else if (daysSinceLastActivity > 1) streakStatus = 'broken';
    }
    
    res.json({
      streakInfo: profile[0] || null,
      streakStatus,
      recentCheckins: checkins,
      totalActiveDays: checkins.length
    });
    
  } catch (error: any) {
    console.error('Get streak details error:', error);
    res.status(500).json({ error: 'Failed to fetch streak details' });
  }
};
export const getCoachDetails = async (req: AuthRequest, res: Response) => {
  try {
    const { coach_id } = req.params;
    const studentId = req.user?.user_id;
    
    // Verify the relationship exists
    const [relationship]: any = await pool.execute(
      'SELECT * FROM coach_student_relationships WHERE coach_user_id = ? AND student_user_id = ? AND status = "active"',
      [coach_id, studentId]
    );
    
    if (relationship.length === 0) {
      return res.status(403).json({ error: 'No active coaching relationship found' });
    }
    
    // Get comprehensive coach details
    const [coach]: any = await pool.execute(`
      SELECT 
        u.user_id,
        u.username,
        u.profile_photo_url,
        u.created_at as joined_date,
        COALESCE(cp.full_name, u.username) as full_name,
        cp.bio,
        cp.specialization,
        cp.years_experience,
        cp.total_students_coached,
        cp.success_stories,
        cp.certification,
        cp.created_at as coach_since,
        
        -- Current student stats
        cp.current_students,
        cp.max_students,
        
        -- Calculate coach ratings if you have a rating system
        COUNT(DISTINCT csr.student_user_id) as active_students,
        AVG(cf.rating) as average_rating,
        COUNT(DISTINCT cf.feedback_id) as total_feedback_given
        
      FROM users u
      LEFT JOIN coach_profiles cp ON u.user_id = cp.user_id
      LEFT JOIN coach_student_relationships csr ON u.user_id = csr.coach_user_id AND csr.status = 'active'
      LEFT JOIN coach_feedback cf ON u.user_id = cf.coach_user_id AND cf.rating IS NOT NULL
      WHERE u.user_id = ? AND u.user_type = 'coach'
      GROUP BY u.user_id
    `, [coach_id]);
    
    if (coach.length === 0) {
      return res.status(404).json({ error: 'Coach not found' });
    }
    
    res.json({ coach: coach[0] });
    
  } catch (error: any) {
    console.error('Get coach details error:', error);
    res.status(500).json({ error: 'Failed to fetch coach details' });
  }
};





src/middleware/adminLogger.ts
// File: backend/middleware/adminLogger.ts
import { Request, Response, NextFunction } from 'express';
import pool from '../config/database';
import { AuthRequest } from './auth';

/**
 * Middleware to log admin actions
 * @param actionType - Type of action being performed
 * @returns Express middleware function
 */
export const logAdminAction = (actionType: string) => {
  return async (req: AuthRequest, res: Response, next: NextFunction) => {
    // Use res.on('finish') instead of overriding res.end
    res.on('finish', async () => {
      // Only log successful requests
      if (res.statusCode >= 200 && res.statusCode < 300) {
        const connection = await pool.getConnection();
        
        try {
          const actionDetails = {
            method: req.method,
            url: req.originalUrl,
            body: req.method !== 'GET' ? req.body : undefined,
            query: req.query,
            status_code: res.statusCode,
            timestamp: new Date().toISOString()
          };

          // Remove sensitive data from logging
          if (actionDetails.body) {
            const sanitizedBody = { ...actionDetails.body };
            delete sanitizedBody.password;
            delete sanitizedBody.password_hash;
            delete sanitizedBody.token;
            actionDetails.body = sanitizedBody;
          }

          await connection.execute(
            'INSERT INTO admin_action_logs (admin_user_id, action_type, target_type, action_details, ip_address, user_agent) VALUES (?, ?, ?, ?, ?, ?)',
            [
              req.user?.user_id || null,
              actionType,
              'system_settings',
              JSON.stringify(actionDetails),
              req.ip || req.connection.remoteAddress,
              req.get('User-Agent') || 'Unknown'
            ]
          );

          // Also update the admin profile's last action
          if (req.user?.user_id) {
            await connection.execute(
              'UPDATE admin_profiles SET last_action = ?, last_action_date = CURRENT_TIMESTAMP WHERE user_id = ?',
              [actionType, req.user.user_id]
            );
          }
        } catch (error) {
          console.error('Failed to log admin action:', error);
        } finally {
          connection.release();
        }
      }
    });

    next();
  };
};

/**
 * Enhanced error logging function
 */
export const logSystemError = async (error: any, req?: Request, user_id?: number) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.execute(
      'INSERT INTO system_error_logs (error_level, error_message, error_stack, endpoint, method, user_id, request_data, ip_address, user_agent) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
      [
        error.severity || 'error',
        error.message || 'Unknown error',
        error.stack || null,
        req?.path || null,
        req?.method || null,
        user_id,
        req ? JSON.stringify({
          body: req.body,
          query: req.query,
          params: req.params
        }) : null,
        req?.ip || null,
        req?.get('User-Agent') || null
      ]
    );
  } catch (logError) {
    console.error('Failed to log system error:', logError);
  } finally {
    connection.release();
  }
};

/**
 * Analytics event logger
 */
export const logUserAnalytics = async (
  userId: number | null, 
  sessionId: string | null, 
  eventType: string, 
  eventData: any = {}, 
  req?: Request
) => {
  const connection = await pool.getConnection();
  
  try {
    // Check if analytics is enabled
    const [analyticsEnabled]: any = await connection.execute(
      'SELECT setting_value FROM system_settings WHERE setting_key = ?',
      ['user_analytics_enabled']
    );

    if (analyticsEnabled.length > 0 && analyticsEnabled[0].setting_value === 'true') {
      await connection.execute(
        'INSERT INTO user_analytics (user_id, session_id, event_type, event_data, page_url, referrer, device_info, ip_address) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
        [
          userId,
          sessionId,
          eventType,
          JSON.stringify(eventData),
          req?.originalUrl || null,
          req?.get('Referrer') || null,
          req ? JSON.stringify({
            user_agent: req.get('User-Agent'),
            accept_language: req.get('Accept-Language'),
            accept_encoding: req.get('Accept-Encoding')
          }) : null,
          req?.ip || null
        ]
      );
    }
  } catch (error) {
    console.error('Failed to log user analytics:', error);
  } finally {
    connection.release();
  }
};

/**
 * Performance monitoring middleware - simplified version
 */
export const performanceMonitor = async (req: Request, res: Response, next: NextFunction) => {
  const startTime = Date.now();

  // Use res.on('finish') to capture response time
  res.on('finish', async () => {
    const responseTime = Date.now() - startTime;
    
    // Log performance if monitoring is enabled
    const connection = await pool.getConnection();
    
    try {
      const [monitoringEnabled]: any = await connection.execute(
        'SELECT setting_value FROM system_settings WHERE setting_key = ?',
        ['performance_monitoring_enabled']
      );

      if (monitoringEnabled.length > 0 && monitoringEnabled[0].setting_value === 'true') {
        const [threshold]: any = await connection.execute(
          'SELECT setting_value FROM system_settings WHERE setting_key = ?',
          ['performance_alert_threshold']
        );

        const alertThreshold = threshold.length > 0 ? parseInt(threshold[0].setting_value) : 500;

        // Always log performance data
        await connection.execute(
          'INSERT INTO performance_logs (endpoint, method, response_time_ms, status_code, user_id, ip_address, user_agent) VALUES (?, ?, ?, ?, ?, ?, ?)',
          [
            req.path,
            req.method,
            responseTime,
            res.statusCode,
            (req as AuthRequest).user?.user_id || null,
            req.ip,
            req.get('User-Agent')
          ]
        );

        // Log as error if response time is too high
        if (responseTime > alertThreshold) {
          await logSystemError({
            message: `Slow response detected: ${responseTime}ms for ${req.method} ${req.path}`,
            severity: 'warn'
          }, req, (req as AuthRequest).user?.user_id);
        }
      }
    } catch (error) {
      console.error('Performance monitoring error:', error);
    } finally {
      connection.release();
    }
  });

  next();
};

/**
 * Data cleanup utility
 */
export const cleanupOldData = async () => {
  const connection = await pool.getConnection();
  
  try {
    const [retentionSetting]: any = await connection.execute(
      'SELECT setting_value FROM system_settings WHERE setting_key = ?',
      ['data_retention_days']
    );

    const retentionDays = retentionSetting.length > 0 ? parseInt(retentionSetting[0].setting_value) : 90;
    const cutoffDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);

    // Clean up old performance logs
    await connection.execute(
      'DELETE FROM performance_logs WHERE created_at < ?',
      [cutoffDate]
    );

    // Clean up old analytics data
    await connection.execute(
      'DELETE FROM user_analytics WHERE created_at < ?',
      [cutoffDate]
    );

    // Clean up resolved error logs older than retention period
    await connection.execute(
      'DELETE FROM system_error_logs WHERE created_at < ? AND resolved = true',
      [cutoffDate]
    );

    console.log(`Data cleanup completed. Removed data older than ${retentionDays} days.`);

  } catch (error) {
    console.error('Data cleanup error:', error);
  } finally {
    connection.release();
  }
};

/**
 * Feature flag checker
 */
export const checkFeatureFlag = async (flagKey: string, userId?: number, userType?: string): Promise<boolean> => {
  const connection = await pool.getConnection();
  
  try {
    const [flag]: any = await connection.execute(
      'SELECT * FROM feature_flags WHERE flag_key = ?',
      [flagKey]
    );

    if (flag.length === 0 || !flag[0].is_enabled) {
      return false;
    }

    const flagData = flag[0];

    // Check rollout percentage
    if (flagData.rollout_percentage < 100) {
      const userHash = userId ? 
        userId.toString().split('').reduce((a: number, b: string) => {
          a = ((a << 5) - a) + b.charCodeAt(0);
          return a & a;
        }, 0) : Math.random() * 100;
      
      if (Math.abs(userHash) % 100 >= flagData.rollout_percentage) {
        return false;
      }
    }

    // Check user type targeting
    if (flagData.target_user_types && userType) {
      let targetTypes: string[];
      try {
        targetTypes = Array.isArray(flagData.target_user_types) 
          ? flagData.target_user_types 
          : JSON.parse(flagData.target_user_types);
      } catch {
        targetTypes = [];
      }
      
      if (targetTypes.length > 0 && !targetTypes.includes(userType)) {
        return false;
      }
    }

    return true;
  } catch (error) {
    console.error('Feature flag check error:', error);
    return false;
  } finally {
    connection.release();
  }
};





src/middleware/auth.ts
// src/middleware/auth.ts
import { Request, Response, NextFunction } from 'express';
import pool from '../config/database';
const jwt = require('jsonwebtoken');
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

export interface AuthRequest extends Request {
  user?: any;
}

// Helper function to validate session in database
const validateSessionInDB = async (sessionId: string, userId: number): Promise<boolean> => {
  const connection = await pool.getConnection();
  
  try {
    const [sessions]: any = await connection.execute(
      'SELECT session_id, expires_at FROM user_sessions WHERE session_id = ? AND user_id = ?',
      [sessionId, userId]
    );
    
    if (sessions.length === 0) {
      return false;
    }
    
    const session = sessions[0];
    const now = new Date();
    const expiry = new Date(session.expires_at);
    
    // Check if session has expired
    if (now > expiry) {
      // Clean up expired session
      await connection.execute(
        'DELETE FROM user_sessions WHERE session_id = ?',
        [sessionId]
      );
      return false;
    }
    
    // Update last activity timestamp
    await connection.execute(
      'UPDATE user_sessions SET last_activity = CURRENT_TIMESTAMP WHERE session_id = ?',
      [sessionId]
    );
    
    return true;
  } catch (error) {
    console.error('Session validation error:', error);
    return false;
  } finally {
    connection.release();
  }
};

// Main authentication middleware
export const authenticate = async (req: AuthRequest, res: Response, next: NextFunction) => {
  const connection = await pool.getConnection();
  
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ 
        error: 'Access token required',
        code: 'NO_TOKEN'
      });
    }
    
    const token = authHeader.split(' ')[1];
    
    // Verify JWT token
    let decoded;
    try {
      decoded = jwt.verify(token, process.env.JWT_SECRET) as any;
    } catch (jwtError: any) {
      if (jwtError.name === 'JsonWebTokenError') {
        return res.status(401).json({ 
          error: 'Invalid token',
          code: 'INVALID_TOKEN'
        });
      } else if (jwtError.name === 'TokenExpiredError') {
        return res.status(401).json({ 
          error: 'Token expired',
          code: 'TOKEN_EXPIRED'
        });
      } else {
        return res.status(401).json({ 
          error: 'Token verification failed',
          code: 'TOKEN_VERIFICATION_FAILED'
        });
      }
    }
    
    // ==================== HANDLE HARDCODED ADMIN (ADD THIS) ====================
// Check if this is the hardcoded admin
if (decoded.isHardcodedAdmin && decoded.user_type === 'admin') {
  console.log('✅ Authenticated as hardcoded admin');
  
  // Attach admin data to request (no database check needed)
  req.user = {
    user_id: decoded.user_id,
    email: decoded.email,
    user_type: 'admin',
    session_id: decoded.session_id,
    username: 'SystemAdmin',
    is_active: true,
    isHardcodedAdmin: true
  };
  
  connection.release();
  return next();
}
// ==================== END HARDCODED ADMIN HANDLING ====================

    // Validate session in database only if session_id exists in token
    // This provides backward compatibility with tokens that don't have session_id
    if (decoded.session_id) {
      try {
        const isValidSession = await validateSessionInDB(decoded.session_id, decoded.user_id);
        if (!isValidSession) {
          return res.status(401).json({ 
            error: 'Session expired or invalid',
            code: 'SESSION_EXPIRED'
          });
        }
      } catch (sessionError) {
        console.error('Session validation error:', sessionError);
        // Continue without session validation if there's a database error
        // This prevents the system from breaking due to temporary DB issues
        console.warn('Continuing without session validation due to DB error');
      }
    }
    
    // Validate user still exists and is active
    const [users]: any = await connection.execute(
      'SELECT user_id, username, is_active FROM users WHERE user_id = ?',
      [decoded.user_id]
    );
    
    if (users.length === 0 || !users[0].is_active) {
      return res.status(401).json({ 
        error: 'User account not found or inactive',
        code: 'ACCOUNT_INACTIVE'
      });
    }
    
    // Attach user data to request
    req.user = {
      user_id: decoded.user_id,
      email: decoded.email,
      user_type: decoded.user_type,
      session_id: decoded.session_id,
      username: users[0].username,
      is_active: users[0].is_active
    };
    
    next();
    
  } catch (error: any) {
    console.error('Authentication error:', error);
    return res.status(401).json({ 
      error: 'Authentication failed',
      code: 'AUTH_FAILED'
    });
  } finally {
    connection.release();
  }
};

export const authorizeRole = (roles: string[]) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    const userType = req.user?.user_type;
    
    if (!userType) {
      return res.status(401).json({ error: 'User type not found' });
    }
    
    if (!roles.includes(userType)) {
      return res.status(403).json({ 
        error: 'Access denied. Insufficient permissions.',
        required_roles: roles,
        user_role: userType
      });
    }
    
    next();
  };
};

// Middleware to check if user is active adventurer
export const requireActiveAdventurer = (req: AuthRequest, res: Response, next: NextFunction) => {
  if (req.user?.user_type !== 'adventurer') {
    return res.status(403).json({ error: 'This endpoint is only for adventurers' });
  }
  
  if (!req.user?.is_active) {
    return res.status(403).json({ error: 'Account is not active' });
  }
  
  next();
};

// Middleware to check if user is active coach
export const requireActiveCoach = (req: AuthRequest, res: Response, next: NextFunction) => {
  if (req.user?.user_type !== 'coach') {
    return res.status(403).json({ error: 'This endpoint is only for coaches' });
  }
  
  if (!req.user?.is_active) {
    return res.status(403).json({ error: 'Account is not active' });
  }
  
  next();
};

// Middleware for optional authentication (doesn't fail if no token)
export const optionalAuth = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      // No token provided, continue without authentication
      return next();
    }
    
    const token = authHeader.split(' ')[1];
    const decoded = jwt.verify(token, process.env.JWT_SECRET) as any;
    
    // Validate session if present
    if (decoded.session_id) {
      try {
        const isValidSession = await validateSessionInDB(decoded.session_id, decoded.user_id);
        if (!isValidSession) {
          // Invalid session, continue without authentication
          return next();
        }
      } catch (sessionError) {
        // Session validation failed, continue without authentication
        console.warn('Session validation failed in optionalAuth:', sessionError);
        return next();
      }
    }
    
    req.user = decoded;
    next();
  } catch (error) {
    // Token is invalid, continue without authentication
    next();
  }
};

// Rate limiting middleware for auth endpoints
export const authRateLimit = (maxAttempts: number = 5, windowMs: number = 15 * 60 * 1000) => {
  const attempts = new Map<string, { count: number; resetTime: number }>();
  
  return (req: Request, res: Response, next: NextFunction) => {
    const clientIP = req.ip || req.connection.remoteAddress || 'unknown';
    const now = Date.now();
    
    // Clean up expired entries
    for (const [ip, data] of attempts.entries()) {
      if (now > data.resetTime) {
        attempts.delete(ip);
      }
    }
    
    const clientAttempts = attempts.get(clientIP);
    
    if (!clientAttempts) {
      attempts.set(clientIP, { count: 1, resetTime: now + windowMs });
      return next();
    }
    
    if (clientAttempts.count >= maxAttempts) {
      return res.status(429).json({ 
        error: 'Too many authentication attempts. Please try again later.',
        retry_after: Math.ceil((clientAttempts.resetTime - now) / 1000)
      });
    }
    
    clientAttempts.count++;
    next();
  };
};
export const requireAdmin = async (req: AuthRequest, res: Response, next: NextFunction) => {
  const connection = await pool.getConnection();
  
  try {
    // User should already be authenticated via authenticate middleware
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    // Check if user is admin
    if (req.user.user_type !== 'admin') {
      return res.status(403).json({ error: 'Admin access required' });
    }

    // Handle hardcoded admin (skip database checks)
    if (req.user.isHardcodedAdmin) {
      return next();
    }

    // Optional: Check IP whitelist if enabled (for regular admin accounts)
    const [ipWhitelistSetting]: any = await connection.execute(
      'SELECT setting_value FROM system_settings WHERE setting_key = ?',
      ['ip_whitelist_enabled']
    );

    if (ipWhitelistSetting.length > 0 && ipWhitelistSetting[0].setting_value === 'true') {
      const clientIP = req.ip || req.connection.remoteAddress;
      
      const [whitelist]: any = await connection.execute(
        'SELECT * FROM admin_ip_whitelist WHERE ip_address = ? AND is_active = true',
        [clientIP]
      );

      if (whitelist.length === 0) {
        // Log unauthorized access attempt
        await connection.execute(
          'INSERT INTO system_error_logs (error_level, error_message, endpoint, method, user_id, ip_address, user_agent) VALUES (?, ?, ?, ?, ?, ?, ?)',
          [
            'warn',
            `Unauthorized admin access attempt from IP: ${clientIP}`,
            req.path,
            req.method,
            req.user.user_id,
            clientIP,
            req.get('User-Agent')
          ]
        );

        return res.status(403).json({ 
          error: 'Access denied: IP not whitelisted' 
        });
      }
    }

    // Check admin profile exists
    const [adminProfile]: any = await connection.execute(
      'SELECT * FROM admin_profiles WHERE user_id = ?',
      [req.user.user_id]
    );

    if (adminProfile.length === 0) {
      return res.status(403).json({ 
        error: 'Admin profile not found' 
      });
    }

    // Attach admin profile to request for use in routes
    req.user.adminProfile = adminProfile[0];
    
    next();
  } catch (error) {
    console.error('Admin auth middleware error:', error);
    res.status(500).json({ error: 'Authentication error' });
  } finally {
    connection.release();
  }
};

// Check specific admin permissions
export const requirePermission = (permission: string) => {
  return async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
      const adminProfile = req.user?.adminProfile;
      
      if (!adminProfile) {
        return res.status(403).json({ error: 'Admin profile required' });
      }

      // SUPER_ADMIN has all permissions
      if (adminProfile.access_level === 'SUPER_ADMIN') {
        return next();
      }

      // Check specific permission
      let permissions;
      try {
        permissions = typeof adminProfile.permissions === 'string' 
          ? JSON.parse(adminProfile.permissions) 
          : adminProfile.permissions;
      } catch (e) {
        permissions = {};
      }

      if (!permissions || !permissions[permission]) {
        return res.status(403).json({ 
          error: `Permission required: ${permission}` 
        });
      }

      next();
    } catch (error) {
      console.error('Permission check error:', error);
      res.status(500).json({ error: 'Permission check failed' });
    }
  };
};
module.exports = {
  requireAdmin,
  requirePermission
};






src/middleware/errorHandler.ts
import { Request, Response, NextFunction } from 'express';

export const errorHandler = (
  err: any,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.error('Error:', err.message);
  
  res.status(err.status || 500).json({
    error: err.message || 'Internal Server Error',
    status: err.status || 500
  });
};


src/middleware/roleCheck.ts
(empty)


src/middleware/upload.ts
const multer = require('multer');
const path = require('path');

const storage = multer.diskStorage({
  destination: (req: any, file: any, cb: any) => {
    cb(null, 'uploads/temp/');
  },
  filename: (req: any, file: any, cb: any) => {
    const uniqueName = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}${path.extname(file.originalname)}`;
    cb(null, uniqueName);
  }
});

const fileFilter = (req: any, file: any, cb: any) => {
  const allowedTypes = /jpeg|jpg|png|gif|webp/;
  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = allowedTypes.test(file.mimetype);
  
  if (mimetype && extname) {
    return cb(null, true);
  } else {
    cb(new Error('Only image files are allowed'));
  }
};

export const upload = multer({
  storage,
  limits: { fileSize: 5 * 1024 * 1024 },
  fileFilter
});




src/routes/adminRoutes.ts
import { Router } from 'express';
import { 
  getDashboardStats,
  getAllUsers,
  getUserDetails,
  createUser,
  updateUser,
  deleteUser,
  toggleUserStatus,
  getAllQuests,
  getAdminLogs,
  getDatabaseStats,
  getAllQuestsDetailed
} from '../controllers/adminController';
import { authenticate, authorizeRole } from '../middleware/auth';

const router = Router();

// All routes require authentication and admin role
router.use(authenticate);
router.use(authorizeRole(['admin']));

// ==================== DASHBOARD ====================
router.get('/dashboard/stats', getDashboardStats);
router.get('/database/stats', getDatabaseStats);

// ==================== USER MANAGEMENT ====================
router.get('/users', getAllUsers);
router.get('/users/:user_id', getUserDetails);
router.post('/users', createUser);
router.put('/users/:user_id', updateUser);
router.delete('/users/:user_id', deleteUser);
router.patch('/users/:user_id/toggle-status', toggleUserStatus);

// ==================== QUEST MANAGEMENT ====================
router.get('/quests', getAllQuestsDetailed);

// ==================== ADMIN LOGS ====================
router.get('/logs', getAdminLogs);

export default router;




src/routes/admin/settings.ts
// File: backend/routes/admin/settings.ts
import express from 'express';
import pool from '../../config/database';
import { authenticate, requireAdmin, type AuthRequest } from '../../middleware/auth';
import { logAdminAction } from '../../middleware/adminLogger';

const router = express.Router();

// Middleware to ensure admin access
router.use(authenticate);
router.use(requireAdmin);

// GET /api/admin/settings - Get all system settings
router.get('/', async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    const [settings]: any = await connection.execute(
      'SELECT * FROM system_settings ORDER BY setting_key'
    );

    // Categorize settings
    const categorizedSettings: any = {
      quest_system: {},
      level_progression: {},
      security: {},
      platform: {},
      monitoring: {},
      coach_system: {}
    };

    settings.forEach((setting: any) => {
      const key = setting.setting_key;
      let value = setting.setting_value;

      // Parse value based on type
      if (setting.setting_type === 'boolean') {
        value = value === 'true' || value === '1';
      } else if (setting.setting_type === 'number') {
        value = parseFloat(value);
      } else if (setting.setting_type === 'json') {
        try {
          value = JSON.parse(value);
        } catch (e) {
          value = setting.setting_value;
        }
      }

      // Categorize the setting
      let category = 'platform';
      if (key.includes('quest') || key.includes('xp') || key.includes('streak')) {
        category = 'quest_system';
      } else if (key.includes('level') || key.includes('prestige') || key.includes('title')) {
        category = 'level_progression';
      } else if (key.includes('login') || key.includes('session') || key.includes('password') || key.includes('ip') || key.includes('two_factor')) {
        category = 'security';
      } else if (key.includes('theme') || key.includes('welcome') || key.includes('maintenance') || key.includes('logo') || key.includes('notification') || key.includes('background')) {
        category = 'platform';
      } else if (key.includes('monitoring') || key.includes('analytics') || key.includes('error') || key.includes('performance') || key.includes('retention') || key.includes('ab_testing')) {
        category = 'monitoring';
      } else if (key.includes('coach')) {
        category = 'coach_system';
      }

      categorizedSettings[category][key] = {
        value,
        type: setting.setting_type,
        description: setting.description
      };
    });

    res.json({
      success: true,
      settings: categorizedSettings
    });

  } catch (error) {
    console.error('Error fetching settings:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch settings'
    });
  } finally {
    connection.release();
  }
});

// PUT /api/admin/settings - Update system settings
router.put('/', logAdminAction('settings_update'), async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const { settings } = req.body;

    if (!settings || typeof settings !== 'object') {
      await connection.rollback();
      return res.status(400).json({
        success: false,
        error: 'Invalid settings data'
      });
    }

    const updatePromises: Promise<any>[] = [];

    // Process each category of settings
    Object.entries(settings).forEach(([category, categorySettings]) => {
      Object.entries(categorySettings as any).forEach(([key, settingData]: [string, any]) => {
        let value = settingData.value;

        // Convert value to string for database storage
        if (typeof value === 'boolean') {
          value = value.toString();
        } else if (typeof value === 'number') {
          value = value.toString();
        } else if (typeof value === 'object') {
          value = JSON.stringify(value);
        }

        updatePromises.push(
          connection.execute(
            `INSERT INTO system_settings (setting_key, setting_value, setting_type, description) 
             VALUES (?, ?, ?, ?) 
             ON DUPLICATE KEY UPDATE 
             setting_value = VALUES(setting_value), 
             updated_at = CURRENT_TIMESTAMP`,
            [
              key,
              value,
              settingData.type || 'string',
              settingData.description || ''
            ]
          )
        );
      });
    });

    await Promise.all(updatePromises);

    // Log the admin action
    await connection.execute(
      'INSERT INTO admin_action_logs (admin_user_id, action_type, target_type, action_details, ip_address, user_agent) VALUES (?, ?, ?, ?, ?, ?)',
      [
        req.user?.user_id,
        'settings_bulk_update',
        'system_settings',
        JSON.stringify({
          updated_settings: Object.keys(settings).map(category => 
            Object.keys((settings as any)[category])
          ).flat(),
          timestamp: new Date().toISOString()
        }),
        req.ip,
        req.get('User-Agent')
      ]
    );

    await connection.commit();

    res.json({
      success: true,
      message: 'Settings updated successfully'
    });

  } catch (error) {
    await connection.rollback();
    console.error('Error updating settings:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update settings'
    });
  } finally {
    connection.release();
  }
});

// POST /api/admin/settings/reset - Reset to default values
router.post('/reset', logAdminAction('settings_reset'), async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    const defaultSettings = {
      daily_quest_count: '8',
      weekly_quest_count: '3',
      level_multiplier: '1.5',
      streak_bonus_xp: '50',
      streak_bonus_enabled: 'true',
      quest_refresh_hour: '0',
      auto_generate_quests: 'true',
      base_xp_per_level: '100',
      max_level_cap: '100',
      title_unlocks_enabled: 'true',
      prestige_system_enabled: 'false',
      max_login_attempts: '5',
      session_lifetime_days: '7',
      two_factor_enabled: 'false',
      ip_whitelist_enabled: 'false',
      password_min_length: '8',
      password_require_special: 'true',
      password_require_numbers: 'true',
      password_require_uppercase: 'false',
      default_theme: 'dark',
      welcome_message: 'Welcome to Solo Leveling Life!',
      maintenance_mode: 'false',
      notification_email_enabled: 'true',
      performance_monitoring_enabled: 'true',
      error_tracking_enabled: 'true',
      analytics_enabled: 'true',
      user_retention_tracking: 'true',
      ab_testing_enabled: 'false'
    };

    await connection.beginTransaction();

    const updatePromises = Object.entries(defaultSettings).map(([key, value]) =>
      connection.execute(
        `INSERT INTO system_settings (setting_key, setting_value, setting_type, description) 
         VALUES (?, ?, 'string', 'Default system setting') 
         ON DUPLICATE KEY UPDATE 
         setting_value = VALUES(setting_value), 
         updated_at = CURRENT_TIMESTAMP`,
        [key, value]
      )
    );

    await Promise.all(updatePromises);

    // Log the admin action
    await connection.execute(
      'INSERT INTO admin_action_logs (admin_user_id, action_type, target_type, action_details, ip_address, user_agent) VALUES (?, ?, ?, ?, ?, ?)',
      [
        req.user?.user_id,
        'settings_reset',
        'system_settings',
        JSON.stringify({
          action: 'Reset all settings to defaults',
          timestamp: new Date().toISOString()
        }),
        req.ip,
        req.get('User-Agent')
      ]
    );

    await connection.commit();

    res.json({
      success: true,
      message: 'Settings reset to defaults successfully'
    });

  } catch (error) {
    await connection.rollback();
    console.error('Error resetting settings:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to reset settings'
    });
  } finally {
    connection.release();
  }
});

// GET /api/admin/settings/export - Export current configuration
router.get('/export', logAdminAction('settings_export'), async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    const [settings]: any = await connection.execute('SELECT * FROM system_settings');
    const [featureFlags]: any = await connection.execute('SELECT * FROM feature_flags');
    const [ipWhitelist]: any = await connection.execute('SELECT * FROM admin_ip_whitelist WHERE is_active = true');

    const exportData = {
      exported_at: new Date().toISOString(),
      exported_by: req.user?.user_id,
      version: '1.0',
      settings: settings.reduce((acc: any, setting: any) => {
        acc[setting.setting_key] = {
          value: setting.setting_value,
          type: setting.setting_type,
          description: setting.description
        };
        return acc;
      }, {}),
      feature_flags: featureFlags,
      ip_whitelist: ipWhitelist.map((ip: any) => ({
        ip_address: ip.ip_address,
        ip_range: ip.ip_range,
        description: ip.description
      }))
    };

    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Content-Disposition', `attachment; filename=solo-leveling-config-${Date.now()}.json`);
    res.json(exportData);

  } catch (error) {
    console.error('Error exporting settings:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to export configuration'
    });
  } finally {
    connection.release();
  }
});

// POST /api/admin/settings/import - Import configuration
router.post('/import', logAdminAction('settings_import'), async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    const { config } = req.body;

    if (!config || !config.settings) {
      await connection.rollback();
      return res.status(400).json({
        success: false,
        error: 'Invalid configuration data'
      });
    }

    const updatePromises = Object.entries(config.settings).map(([key, data]: [string, any]) =>
      connection.execute(
        `INSERT INTO system_settings (setting_key, setting_value, setting_type, description) 
         VALUES (?, ?, ?, ?) 
         ON DUPLICATE KEY UPDATE 
         setting_value = VALUES(setting_value), 
         updated_at = CURRENT_TIMESTAMP`,
        [key, data.value, data.type, data.description || '']
      )
    );

    await Promise.all(updatePromises);

    // Log the admin action
    await connection.execute(
      'INSERT INTO admin_action_logs (admin_user_id, action_type, target_type, action_details, ip_address, user_agent) VALUES (?, ?, ?, ?, ?, ?)',
      [
        req.user?.user_id,
        'settings_import',
        'system_settings',
        JSON.stringify({
          imported_from: config.exported_at || 'Unknown',
          settings_count: Object.keys(config.settings).length,
          timestamp: new Date().toISOString()
        }),
        req.ip,
        req.get('User-Agent')
      ]
    );

    await connection.commit();

    res.json({
      success: true,
      message: 'Configuration imported successfully'
    });

  } catch (error) {
    await connection.rollback();
    console.error('Error importing settings:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to import configuration'
    });
  } finally {
    connection.release();
  }
});

// Feature Flags endpoints
router.get('/feature-flags', async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    const [flags]: any = await connection.execute(
      'SELECT * FROM feature_flags ORDER BY flag_name'
    );

    res.json({
      success: true,
      flags
    });

  } catch (error) {
    console.error('Error fetching feature flags:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch feature flags'
    });
  } finally {
    connection.release();
  }
});

router.post('/feature-flags', logAdminAction('feature_flag_create'), async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    const { flag_key, flag_name, description, is_enabled, rollout_percentage } = req.body;

    const [result]: any = await connection.execute(
      `INSERT INTO feature_flags (flag_key, flag_name, description, is_enabled, rollout_percentage, created_by) 
       VALUES (?, ?, ?, ?, ?, ?)`,
      [flag_key, flag_name, description || '', is_enabled || false, rollout_percentage || 0, req.user?.user_id]
    );

    res.json({
      success: true,
      flag: { flag_id: result.insertId, flag_key, flag_name, description, is_enabled, rollout_percentage }
    });

  } catch (error) {
    console.error('Error creating feature flag:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to create feature flag'
    });
  } finally {
    connection.release();
  }
});

router.put('/feature-flags/:flag_id', logAdminAction('feature_flag_update'), async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    const { flag_id } = req.params;
    const { flag_name, description, is_enabled, rollout_percentage } = req.body;

    await connection.execute(
      `UPDATE feature_flags 
       SET flag_name = ?, description = ?, is_enabled = ?, rollout_percentage = ?, updated_at = CURRENT_TIMESTAMP 
       WHERE flag_id = ?`,
      [flag_name, description, is_enabled, rollout_percentage, flag_id]
    );

    res.json({
      success: true,
      message: 'Feature flag updated successfully'
    });

  } catch (error) {
    console.error('Error updating feature flag:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update feature flag'
    });
  } finally {
    connection.release();
  }
});

router.delete('/feature-flags/:flag_id', logAdminAction('feature_flag_delete'), async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    const { flag_id } = req.params;

    await connection.execute('DELETE FROM feature_flags WHERE flag_id = ?', [flag_id]);

    res.json({
      success: true,
      message: 'Feature flag deleted successfully'
    });

  } catch (error) {
    console.error('Error deleting feature flag:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to delete feature flag'
    });
  } finally {
    connection.release();
  }
});

// IP Whitelist endpoints
router.get('/ip-whitelist', async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    const [whitelist]: any = await connection.execute(
      'SELECT * FROM admin_ip_whitelist ORDER BY created_at DESC'
    );

    res.json({
      success: true,
      whitelist
    });

  } catch (error) {
    console.error('Error fetching IP whitelist:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch IP whitelist'
    });
  } finally {
    connection.release();
  }
});

router.post('/ip-whitelist', logAdminAction('ip_whitelist_add'), async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    const { ip_address, ip_range, description } = req.body;

    const [result]: any = await connection.execute(
      `INSERT INTO admin_ip_whitelist (ip_address, ip_range, description, created_by) 
       VALUES (?, ?, ?, ?)`,
      [ip_address, ip_range || null, description || '', req.user?.user_id]
    );

    res.json({
      success: true,
      entry: { whitelist_id: result.insertId, ip_address, ip_range, description }
    });

  } catch (error) {
    console.error('Error adding IP to whitelist:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to add IP to whitelist'
    });
  } finally {
    connection.release();
  }
});

router.delete('/ip-whitelist/:whitelist_id', logAdminAction('ip_whitelist_remove'), async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    const { whitelist_id } = req.params;

    await connection.execute('DELETE FROM admin_ip_whitelist WHERE whitelist_id = ?', [whitelist_id]);

    res.json({
      success: true,
      message: 'IP removed from whitelist successfully'
    });

  } catch (error) {
    console.error('Error removing IP from whitelist:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to remove IP from whitelist'
    });
  } finally {
    connection.release();
  }
});

// System Health endpoint
router.get('/system-health', async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    // Get recent errors
    const [recentErrors]: any = await connection.execute(
      `SELECT COUNT(*) as count 
       FROM system_error_logs 
       WHERE created_at > DATE_SUB(NOW(), INTERVAL 1 HOUR) AND resolved = false`
    );

    // Get performance metrics
    const [performanceMetrics]: any = await connection.execute(
      `SELECT * FROM system_performance_logs 
       WHERE created_at > DATE_SUB(NOW(), INTERVAL 1 HOUR) 
       ORDER BY created_at DESC 
       LIMIT 100`
    );

    // Calculate average response time
    const avgResponseTime = performanceMetrics.length > 0
      ? performanceMetrics.reduce((sum: number, p: any) => sum + p.response_time_ms, 0) / performanceMetrics.length
      : 0;

    // Get active users
    const [activeUsers]: any = await connection.execute(
      `SELECT COUNT(DISTINCT user_id) as count 
       FROM user_analytics 
       WHERE created_at > DATE_SUB(NOW(), INTERVAL 24 HOUR)`
    );

    // Get error counts by level
    const [errorCounts]: any = await connection.execute(
      `SELECT error_level, COUNT(*) as count 
       FROM system_error_logs 
       WHERE created_at > DATE_SUB(NOW(), INTERVAL 24 HOUR) 
       GROUP BY error_level`
    );

    res.json({
      success: true,
      health: {
        database: recentErrors[0]?.count > 10 ? 'unhealthy' : 'healthy',
        average_response_time: Math.round(avgResponseTime),
        active_users: activeUsers[0]?.count || 0,
        error_counts: errorCounts.reduce((acc: any, error: any) => {
          acc[error.error_level] = error.count;
          return acc;
        }, {}),
        performance_metrics: performanceMetrics.slice(0, 100),
        timestamp: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('Error fetching system health:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch system health',
      health: {
        database: 'unhealthy',
        average_response_time: -1,
        active_users: 0,
        error_counts: {},
        performance_metrics: [],
        timestamp: new Date().toISOString()
      }
    });
  } finally {
    connection.release();
  }
});

// Analytics endpoint
router.get('/analytics', async (req: AuthRequest, res) => {
  const connection = await pool.getConnection();
  
  try {
    const { timeframe = '7d' } = req.query;
    
    let interval: string;
    switch (timeframe) {
      case '24h':
        interval = '24 HOUR';
        break;
      case '30d':
        interval = '30 DAY';
        break;
      default:
        interval = '7 DAY';
    }

    // User activity
    const [userActivity]: any = await connection.execute(
      `SELECT 
        DATE(created_at) as date, 
        COUNT(DISTINCT user_id) as active_users,
        COUNT(*) as total_events
       FROM user_analytics 
       WHERE created_at > DATE_SUB(NOW(), INTERVAL ${interval})
       GROUP BY DATE(created_at)
       ORDER BY date DESC`
    );

    // Quest completions
    const [questStats]: any = await connection.execute(
      `SELECT 
        DATE(completed_at) as date,
        COUNT(*) as completions,
        SUM(xp_reward) as total_xp
       FROM quest_history 
       WHERE completed_at > DATE_SUB(NOW(), INTERVAL ${interval}) AND status = 'completed'
       GROUP BY DATE(completed_at)
       ORDER BY date DESC`
    );

    // Error trends
    const [errorTrends]: any = await connection.execute(
      `SELECT 
        DATE(created_at) as date,
        error_level,
        COUNT(*) as count
       FROM system_error_logs 
       WHERE created_at > DATE_SUB(NOW(), INTERVAL ${interval})
       GROUP BY DATE(created_at), error_level
       ORDER BY date DESC`
    );

    res.json({
      success: true,
      analytics: {
        user_activity: userActivity,
        quest_stats: questStats,
        error_trends: errorTrends,
        timeframe
      }
    });

  } catch (error) {
    console.error('Error fetching analytics:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch analytics'
    });
  } finally {
    connection.release();
  }
});

export default router;






src/routes/authRoutes.ts
import { Router } from 'express';
import { signup, login, logout, getLoginStats } from '../controllers/authController';
import { authenticate, authorizeRole } from '../middleware/auth';
import { upload } from '../middleware/upload';

const router = Router();

// Public routes
router.post('/signup', upload.single('profile_photo'), signup);
router.post('/login', login);

// Protected routes
router.post('/logout', authenticate, logout);

// Admin routes for login statistics (only for coaches/admins)
router.get('/login-stats', authenticate, authorizeRole(['coach']), getLoginStats);

// Health check for auth service
router.get('/health', (req, res) => {
  res.json({ 
    status: 'OK',
    service: 'Authentication Service',
    timestamp: new Date().toISOString()
  });
});

export default router;




src/routes/coachRoutes.ts
import { Router } from 'express';
import { verifyAndGetStudent, getMyStudents, provideFeedback, removeStudent, getStudentStats  } from '../controllers/coachController';
import { authenticate, authorizeRole } from '../middleware/auth';

const router = Router();

router.use(authenticate);
router.use(authorizeRole(['coach']));

router.post('/verify-student', verifyAndGetStudent);
router.get('/my-students', getMyStudents);
router.get('/student-stats/:student_id', getStudentStats);
router.post('/feedback', provideFeedback);
router.delete('/remove-student/:student_id', removeStudent);
export default router;



src/routes/index.ts
import { Router } from 'express';
import authRoutes from './authRoutes';
import userRoutes from './userRoutes';
import questRoutes from './questRoutes';
import coachRoutes from './coachRoutes';
import adminRoutes from './adminRoutes';

const router = Router();

// Mount all routes
router.use('/auth', authRoutes);
router.use('/users', userRoutes);
router.use('/quests', questRoutes);
router.use('/coach', coachRoutes);
router.use('/admin', adminRoutes);

// Health check endpoint
router.get('/health', (req, res) => {
  res.json({ 
    status: 'OK',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development'
  });
});

// API info endpoint
router.get('/', (req, res) => {
  res.json({
    name: 'Solo Leveling System API',
    version: '1.0.0',
    endpoints: {
      auth: '/api/auth',
      users: '/api/users',
      quests: '/api/quests',
      coach: '/api/coach',
      health: '/api/health'
    }
  });
});

export default router;




src/routes/questRoutes.ts
import { Router } from 'express';
import { 
  getDailyQuests, 
  getWeeklyQuests, 
  completeQuest,
  generateDailyQuests,
  generateWeeklyQuests,
  initializeQuestSystem,
  processQuestExpiration,  
  triggerQuestReset,      
  checkQuestStatus 
} from '../controllers/questController';
import { authenticate, authorizeRole } from '../middleware/auth';

const router = Router();

router.use(authenticate);
router.use(authorizeRole(['adventurer']));

// Quest endpoints
router.get('/daily', getDailyQuests);
router.get('/weekly', getWeeklyQuests);
router.post('/initialize', initializeQuestSystem);
router.post('/generate-daily', generateDailyQuests);
router.post('/generate-weekly', generateWeeklyQuests);
router.post('/complete/:quest_id', completeQuest);

router.post('/expire-and-renew', processQuestExpiration);  // Admin/system use
router.post('/reset-quests', triggerQuestReset);           // Manual reset
router.get('/status', checkQuestStatus);                   // Check if user needs new quests

export default router;


src/routes/userRoutes.ts
import { Router } from 'express';
import { 
  getUserProfile, 
  getUserStats, 
  getAchievements,
  initializeUserStats,
  checkAchievements,
  uploadProfilePhoto,
  removeProfilePhoto,
  getReceivedFeedback,        // Add this
  markFeedbackAsRead ,         // Add this
  recalculateUserStreak,    // Add this import
  getUserStreakDetails,      // Add this import
  getCoachDetails
} from '../controllers/userController';
import { authenticate } from '../middleware/auth';
import { upload } from '../middleware/upload';

const router = Router();

router.use(authenticate);

// Existing routes...
router.get('/profile', getUserProfile);
router.get('/stats', getUserStats);
router.get('/achievements', getAchievements);
router.post('/initialize-stats', initializeUserStats);
router.post('/check-achievements', checkAchievements);
router.post('/upload-photo', upload.single('profile_photo'), uploadProfilePhoto);
router.delete('/remove-photo', removeProfilePhoto);

// New routes for feedback
router.get('/received-feedback', getReceivedFeedback);           // Add this
router.put('/feedback/:feedback_id/read', markFeedbackAsRead);   // Add this

router.post('/recalculate-streak', recalculateUserStreak);
router.get('/streak-details', getUserStreakDetails);

router.get('/coach/:coach_id/details', getCoachDetails);

export default router;








src/schedulers/questScheduler.ts
// src/schedulers/questScheduler.ts
import cron from 'node-cron';
import  pool from '../config/database';
import { shuffleArray, isQuestUnique } from '../controllers/questController';
interface QuestTemplate {
  quest_template_id: number;
  quest_title: string;
  quest_description: string;
  base_xp: number;
  difficulty: string;
  related_stat: string;
  field_name: string;
}
/**
 * AUTOMATIC QUEST GENERATION SYSTEM
 * This scheduler ensures every user gets fresh quests automatically
 * without any manual intervention
 */

// Generate daily quests for all users at midnight
export const scheduleDailyQuestGeneration = () => {
  cron.schedule('0 0 * * *', async () => {
    console.log('🔄 [CRON] Starting midnight daily quest reset...');
    
    try {
      const connection = await pool.getConnection();
      await connection.beginTransaction();
      
      // Get all active users
      const [users]: any = await connection.execute(`
        SELECT u.user_id, ap.field_of_interest, ap.full_name
        FROM users u
        JOIN adventurer_profiles ap ON u.user_id = ap.user_id
        WHERE u.is_active = true AND u.user_type = 'adventurer'
      `);
      
      let successCount = 0;
      let errorCount = 0;
      
      for (const user of users) {
        try {
          // Clear all existing daily quests
          await connection.execute(
            'DELETE FROM user_active_quests WHERE user_id = ? AND quest_type = "daily"',
            [user.user_id]
          );
          
          // Get quest templates with proper typing
          const [templates]: [QuestTemplate[], any] = await connection.execute(
            `SELECT DISTINCT quest_template_id, quest_title, quest_description, base_xp, difficulty, related_stat, field_name
             FROM quest_templates 
             WHERE field_name = ? AND quest_type = 'daily' AND is_active = 1 
             ORDER BY RAND()`,
            [user.field_of_interest]
          );
          
          // Apply uniqueness logic
          const shuffledTemplates = shuffleArray(templates);
          const selectedQuests: QuestTemplate[] = [];
          const usedQuestIds = new Set<number>();
          const usedQuestTitles = new Set<string>();
          
          for (const template of shuffledTemplates) {
            if (selectedQuests.length >= 8) break;
            
            if (usedQuestIds.has(template.quest_template_id)) continue;
            if (!isQuestUnique(template.quest_title, usedQuestTitles)) continue;
            
            selectedQuests.push(template);
            usedQuestIds.add(template.quest_template_id);
            usedQuestTitles.add(template.quest_title.toLowerCase().trim());
          }
          
          // Get backup quests if needed
          if (selectedQuests.length < 8) {
            const [backupTemplates]: [QuestTemplate[], any] = await connection.execute(
              `SELECT DISTINCT quest_template_id, quest_title, quest_description, base_xp, difficulty, related_stat, field_name
               FROM quest_templates 
               WHERE quest_type = 'daily' AND is_active = 1 AND field_name != ?
               ORDER BY RAND() 
               LIMIT ?`,
              [user.field_of_interest, 20]
            );
            
            const shuffledBackups = shuffleArray(backupTemplates);
            
            for (const template of shuffledBackups) {
              if (selectedQuests.length >= 8) break;
              
              if (!usedQuestIds.has(template.quest_template_id) && 
                  isQuestUnique(template.quest_title, usedQuestTitles)) {
                
                selectedQuests.push(template);
                usedQuestIds.add(template.quest_template_id);
                usedQuestTitles.add(template.quest_title.toLowerCase().trim());
              }
            }
          }
          
          // Insert exactly 8 unique quests
          const finalQuests = shuffleArray(selectedQuests).slice(0, 8);
          
          for (const template of finalQuests) {
            await connection.execute(
              `INSERT INTO user_active_quests 
               (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
               VALUES (?, ?, 'daily', CURDATE(), DATE_ADD(NOW(), INTERVAL 1 DAY))`,
              [user.user_id, template.quest_template_id]
            );
          }
          
          successCount++;
          console.log(`✅ Generated ${finalQuests.length} unique quests for ${user.full_name}`);
          
        } catch (userError) {
          errorCount++;
          console.error(`❌ Failed for user ${user.user_id}:`, userError);
        }
      }
      
      await connection.commit();
      connection.release();
      
      console.log(`✨ [MIDNIGHT RESET] Complete! Success: ${successCount}, Errors: ${errorCount}`);
      
    } catch (error) {
      console.error('💥 [MIDNIGHT RESET] Failed:', error);
    }
  }, {
    scheduled: true,
    timezone: "America/New_York" // Change to your timezone
  });
  
  console.log('✅ Midnight quest reset scheduler initialized');
};

// Generate weekly quests every Monday at 00:00
export const scheduleWeeklyQuestGeneration = () => {
  // Run every Monday at midnight
  cron.schedule('0 0 * * 1', async () => {
    console.log('🔄 [CRON] Starting automatic weekly quest generation...');
    
    try {
      const connection = await pool.getConnection();
      
      const [users]: any = await connection.execute(`
        SELECT u.user_id, ap.field_of_interest, ap.full_name
        FROM users u
        JOIN adventurer_profiles ap ON u.user_id = ap.user_id
        WHERE u.is_active = true
      `);
      
      let successCount = 0;
      
      for (const user of users) {
        try {
          // Clear expired weekly quests
          await connection.execute(
            'DELETE FROM user_active_quests WHERE user_id = ? AND quest_type = "weekly" AND expires_at < NOW()',
            [user.user_id]
          );
          
          // Check if user already has weekly quests for this week
          const [existingQuests]: any = await connection.execute(
            'SELECT COUNT(*) as count FROM user_active_quests WHERE user_id = ? AND quest_type = "weekly" AND WEEK(assigned_date) = WEEK(CURDATE())',
            [user.user_id]
          );
          
          if (existingQuests[0].count === 0) {
            // Generate new weekly quests
            const [templates]: any = await connection.execute(
              `SELECT * FROM quest_templates 
               WHERE field_name = ? AND quest_type = 'weekly' AND is_active = 1 
               ORDER BY RAND() 
               LIMIT 3`,
              [user.field_of_interest]
            );
            
            // Insert quest assignments
            for (const template of templates) {
              await connection.execute(
                `INSERT INTO user_active_quests 
                 (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
                 VALUES (?, ?, 'weekly', CURDATE(), DATE_ADD(NOW(), INTERVAL 7 DAY))`,
                [user.user_id, template.quest_template_id]
              );
            }
            
            successCount++;
            console.log(`✅ Generated weekly quests for ${user.full_name}`);
          }
        } catch (userError) {
          console.error(`❌ Failed weekly quests for user ${user.user_id}:`, userError);
        }
      }
      
      connection.release();
      console.log(`✨ [CRON] Weekly quest generation complete! Success: ${successCount}`);
      
    } catch (error) {
      console.error('💥 [CRON] Weekly quest generation failed:', error);
    }
  });
  
  console.log('✅ Weekly quest scheduler initialized (runs every Monday at midnight)');
};

// Initialize quests for new users automatically
export const initializeNewUserQuests = async (userId: number, fieldOfInterest: string) => {
  console.log(`🎯 Initializing quests for new user ${userId} (${fieldOfInterest})...`);
  
  try {
    const connection = await pool.getConnection();
    await connection.beginTransaction();
    
    // Generate initial daily quests
    const [dailyTemplates]: any = await connection.execute(
      `SELECT * FROM quest_templates 
       WHERE field_name = ? AND quest_type = 'daily' AND is_active = 1 
       ORDER BY RAND() 
       LIMIT 8`,
      [fieldOfInterest]
    );
    
    // Generate initial weekly quests
    const [weeklyTemplates]: any = await connection.execute(
      `SELECT * FROM quest_templates 
       WHERE field_name = ? AND quest_type = 'weekly' AND is_active = 1 
       ORDER BY RAND() 
       LIMIT 3`,
      [fieldOfInterest]
    );
    
    // Insert daily quests
    for (const template of dailyTemplates) {
      await connection.execute(
        `INSERT INTO user_active_quests 
         (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
         VALUES (?, ?, 'daily', CURDATE(), DATE_ADD(NOW(), INTERVAL 1 DAY))`,
        [userId, template.quest_template_id]
      );
    }
    
    // Insert weekly quests
    for (const template of weeklyTemplates) {
      await connection.execute(
        `INSERT INTO user_active_quests 
         (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
         VALUES (?, ?, 'weekly', CURDATE(), DATE_ADD(NOW(), INTERVAL 7 DAY))`,
        [userId, template.quest_template_id]
      );
    }
    
    // Initialize user stats based on field
    const [statsTemplate]: any = await connection.execute(
      'SELECT * FROM stats_template WHERE field_name = ?',
      [fieldOfInterest]
    );
    
    for (const stat of statsTemplate) {
      await connection.execute(
        `INSERT INTO user_stats (user_id, stat_name, stat_icon, current_value, max_value)
         VALUES (?, ?, ?, ?, ?)`,
        [userId, stat.stat_name, stat.stat_icon, stat.initial_value, stat.max_value]
      );
    }
    
    await connection.commit();
    connection.release();
    
    console.log(`✅ Successfully initialized ${dailyTemplates.length} daily and ${weeklyTemplates.length} weekly quests for user ${userId}`);
    
    return {
      dailyQuests: dailyTemplates.length,
      weeklyQuests: weeklyTemplates.length,
      stats: statsTemplate.length
    };
    
  } catch (error) {
    console.error('❌ Failed to initialize new user quests:', error);
    throw error;
  }
};

// Start all schedulers
export const startAllSchedulers = () => {
  console.log('🚀 Starting automatic quest generation system...');
  scheduleDailyQuestGeneration();
  scheduleWeeklyQuestGeneration();
  console.log('✨ All quest schedulers are now active!');
};
export const generateDailyQuestsForUser = async (userId: number, fieldOfInterest: string) => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    // Clear existing daily quests for today
    await connection.execute(
      'DELETE FROM user_active_quests WHERE user_id = ? AND quest_type = "daily" AND DATE(assigned_date) = CURDATE()',
      [userId]
    );
    
    // Get ALL available daily quest templates for this field (no duplicates)
    const [templates]: any = await connection.execute(
      `SELECT DISTINCT quest_template_id, field_name, quest_title, quest_description, base_xp, difficulty, related_stat
       FROM quest_templates 
       WHERE field_name = ? AND quest_type = 'daily' AND is_active = 1 
       ORDER BY RAND()`,
      [fieldOfInterest]
    );
    
    console.log(`Found ${templates.length} unique daily quest templates for ${fieldOfInterest}`);
    
    // Determine how many quests to assign
    let questsToAssign;
    if (templates.length >= 8) {
      // If we have 8+ templates, assign 8 random ones
      questsToAssign = templates.slice(0, 8);
    } else if (templates.length >= 4) {
      // If we have 4-7 templates, assign all of them
      questsToAssign = templates;
    } else if (templates.length > 0) {
      // If we have 1-3 templates, assign them + fill with generic ones
      questsToAssign = [...templates];
      
      // Add generic quests to reach 6 total
      const genericQuests = [
        { quest_title: 'Morning Routine', base_xp: 25, difficulty: 'easy', related_stat: 'Stamina' },
        { quest_title: 'Study/Practice Session', base_xp: 35, difficulty: 'medium', related_stat: 'Intelligence' },
        { quest_title: 'Physical Exercise', base_xp: 30, difficulty: 'medium', related_stat: 'Strength' },
        { quest_title: 'Skill Development', base_xp: 40, difficulty: 'medium', related_stat: 'Intelligence' },
        { quest_title: 'Healthy Meal Planning', base_xp: 20, difficulty: 'easy', related_stat: 'Wisdom' },
      ];
      
      const needed = Math.min(6 - templates.length, genericQuests.length);
      for (let i = 0; i < needed; i++) {
        questsToAssign.push({
          quest_template_id: null,
          ...genericQuests[i]
        });
      }
    } else {
      // No templates found - use all generic quests
      questsToAssign = [
        { quest_template_id: null, quest_title: 'Morning Routine', base_xp: 25, difficulty: 'easy', related_stat: 'Stamina' },
        { quest_template_id: null, quest_title: 'Study/Practice Session', base_xp: 35, difficulty: 'medium', related_stat: 'Intelligence' },
        { quest_template_id: null, quest_title: 'Physical Exercise', base_xp: 30, difficulty: 'medium', related_stat: 'Strength' },
        { quest_template_id: null, quest_title: 'Skill Development', base_xp: 40, difficulty: 'medium', related_stat: 'Intelligence' },
        { quest_template_id: null, quest_title: 'Healthy Meal Planning', base_xp: 20, difficulty: 'easy', related_stat: 'Wisdom' },
        { quest_template_id: null, quest_title: 'Evening Reflection', base_xp: 20, difficulty: 'easy', related_stat: 'Wisdom' }
      ];
    }
    
    // Insert the assigned quests (NO DUPLICATES)
    for (const quest of questsToAssign) {
      await connection.execute(
        `INSERT INTO user_active_quests 
         (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
         VALUES (?, ?, 'daily', CURDATE(), DATE_ADD(NOW(), INTERVAL 1 DAY))`,
        [userId, quest.quest_template_id]
      );
    }
    
    await connection.commit();
    console.log(`✅ Assigned ${questsToAssign.length} unique daily quests to user ${userId}`);
    
    return questsToAssign;
    
  } catch (error) {
    await connection.rollback();
    console.error(`❌ Failed to generate daily quests for user ${userId}:`, error);
    throw error;
  } finally {
    connection.release();
  }
};

/**
 * Automated Quest Expiration Scheduler
 * Runs every day at midnight to expire old quests and generate new ones
 */

const generateUniqueQuestsForUser = async (connection: any, userId: number, fieldOfInterest: string) => {
  // Same logic as in questController - you might want to extract this to a shared utility
  try {
    const [templates]: any = await connection.execute(
      `SELECT * FROM quest_templates 
       WHERE field_name = ? AND quest_type = 'daily' AND is_active = 1 
       ORDER BY RAND()`,
      [fieldOfInterest]
    );
    
    // Apply uniqueness logic (shortened for brevity)
    const selectedQuests: any[] = [];
    const usedQuestIds = new Set<number>();
    const usedQuestTitles = new Set<string>();
    
    // Selection logic here...
    for (const template of templates) {
      if (selectedQuests.length >= 8) break;
      if (usedQuestIds.has(template.quest_template_id)) continue;
      
      selectedQuests.push(template);
      usedQuestIds.add(template.quest_template_id);
      usedQuestTitles.add(template.quest_title.toLowerCase().trim());
    }
    
    // Insert new quests
    for (const template of selectedQuests.slice(0, 8)) {
      await connection.execute(
        `INSERT INTO user_active_quests 
         (user_id, quest_template_id, quest_type, assigned_date, expires_at) 
         VALUES (?, ?, 'daily', CURDATE(), DATE_ADD(NOW(), INTERVAL 1 DAY))`,
        [userId, template.quest_template_id]
      );
    }
    
    return selectedQuests;
  } catch (error) {
    console.error('Generate quests error:', error);
    return [];
  }
};

const automatedQuestReset = async () => {
  const connection = await pool.getConnection();
  
  try {
    await connection.beginTransaction();
    
    console.log(`[${new Date().toISOString()}] 🕒 Starting automated daily quest reset...`);
    
    // Step 1: Expire uncompleted daily quests
    const [expired]: any = await connection.execute(
      `UPDATE user_active_quests 
       SET expires_at = NOW() - INTERVAL 1 SECOND
       WHERE quest_type = 'daily' 
       AND expires_at < NOW() 
       AND is_completed = FALSE`
    );
    
    console.log(`⏰ Expired ${expired.affectedRows} uncompleted daily quests`);
    
    // Step 2: Get users needing new quests
    const [users]: any = await connection.execute(
      `SELECT DISTINCT u.user_id, ap.field_of_interest, u.email
       FROM users u
       JOIN adventurer_profiles ap ON u.user_id = ap.user_id
       LEFT JOIN user_active_quests uaq ON u.user_id = uaq.user_id 
         AND uaq.quest_type = 'daily' 
         AND uaq.expires_at > NOW()
       WHERE u.user_type = 'adventurer' 
       AND uaq.user_id IS NULL`
    );
    
    console.log(`👥 Generating fresh quests for ${users.length} users`);
    
    // Step 3: Generate new quests for each user
    let successCount = 0;
    for (const user of users) {
      try {
        const newQuests = await generateUniqueQuestsForUser(
          connection, 
          user.user_id, 
          user.field_of_interest
        );
        
        if (newQuests.length > 0) {
          successCount++;
        }
      } catch (userError) {
        console.error(`Error for user ${user.email}:`, userError);
      }
    }
    
    // Step 4: Clean up old expired quests
    const [cleanup]: any = await connection.execute(
      `DELETE FROM user_active_quests 
       WHERE expires_at < NOW() - INTERVAL 7 DAY 
       AND is_completed = FALSE`
    );
    
    await connection.commit();
    
    console.log(`✅ Quest reset complete: ${successCount}/${users.length} users renewed, ${cleanup.affectedRows} old quests cleaned`);
    
  } catch (error) {
    await connection.rollback();
    console.error('Automated quest reset error:', error);
  } finally {
    connection.release();
  }
};

// Schedule the automated quest reset
export const startQuestScheduler = () => {
  // Run every day at midnight (00:00)
  cron.schedule('0 0 * * *', automatedQuestReset, {
    scheduled: true,
    timezone: "America/New_York" // Change to your timezone
  });
  
  // Optional: Run every hour for testing (comment out in production)
  // cron.schedule('0 * * * *', automatedQuestReset);
  
  console.log('🚀 Quest scheduler started - will reset daily quests at midnight');
};

export default { startQuestScheduler };






src/scripts/dataCleanup.ts
const { PrismaClient } = require('@prisma/client');
const SystemSettingsUtil = require('../utils/systemSettings');

const prisma = new PrismaClient();

async function performDataCleanup() {
  console.log('Starting automated data cleanup...');
  
  try {
    const retentionDays = await SystemSettingsUtil.getSetting('data_retention_days', 90);
    const cutoffDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);

    // Clean up old performance logs
    const deletedPerformance = await prisma.performance_logs.deleteMany({
      where: {
        created_at: { lt: cutoffDate }
      }
    });

    // Clean up old analytics data
    const deletedAnalytics = await prisma.user_analytics.deleteMany({
      where: {
        created_at: { lt: cutoffDate }
      }
    });

    // Clean up resolved error logs
    const deletedErrors = await prisma.system_error_logs.deleteMany({
      where: {
        created_at: { lt: cutoffDate },
        resolved: true
      }
    });

    // Clean up expired sessions
    const deletedSessions = await prisma.user_sessions.deleteMany({
      where: {
        expires_at: { lt: new Date() }
      }
    });

    console.log('Data cleanup completed:', {
      performance_logs_deleted: deletedPerformance.count,
      analytics_deleted: deletedAnalytics.count,
      error_logs_deleted: deletedErrors.count,
      sessions_deleted: deletedSessions.count,
      retention_days: retentionDays
    });

  } catch (error) {
    console.error('Data cleanup failed:', error);
  } finally {
    await prisma.$disconnect();
  }
}

// Run cleanup if called directly
if (require.main === module) {
  performDataCleanup();
}

module.exports = performDataCleanup;







src/services/authService.ts
(Empty)



src/services/levelService.ts
(empty)



src/services/questService.ts
import pool from '../config/database';

export const resetDailyQuests = async () => {
  try {
    console.log('Starting daily quest reset...');
    
    const [users]: any = await pool.execute(
      'SELECT user_id FROM adventurer_profiles'
    );
    
    for (const user of users) {
      await pool.execute('CALL AssignDailyQuests(?)', [user.user_id]);
    }
    
    console.log('✅ Daily quests reset completed');
  } catch (error: any) {
    console.error('❌ Daily quest reset failed:', error.message);
  }
};

src/types/index.ts
export interface User {
  user_id: number;
  email: string;
  username: string;
  user_type: 'adventurer' | 'coach';
  profile_photo_url?: string;
}

export interface JwtPayload {
  user_id: number;
  email: string;
  user_type: string;
}

src/utils/helpers.ts
(empty)


src/utils/jwt.ts
(empty)



src/utils/systemSettings.ts
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

export class SystemSettingsUtil {
  static async getSetting(key, defaultValue = null) {
    try {
      const setting = await prisma.system_settings.findUnique({
        where: { setting_key: key }
      });

      if (!setting) return defaultValue;

      // Parse value based on type
      switch (setting.setting_type) {
        case 'number':
          return parseFloat(setting.setting_value);
        case 'boolean':
          return setting.setting_value === 'true';
        case 'json':
          try {
            return JSON.parse(setting.setting_value);
          } catch {
            return defaultValue;
          }
        default:
          return setting.setting_value;
      }
    } catch (error) {
      console.error(`Error getting setting ${key}:`, error);
      return defaultValue;
    }
  }

  static async setSetting(key, value, type = 'string', description = '') {
    try {
      let stringValue;
      switch (type) {
        case 'boolean':
          stringValue = value.toString();
          break;
        case 'number':
          stringValue = value.toString();
          break;
        case 'json':
          stringValue = JSON.stringify(value);
          break;
        default:
          stringValue = value;
      }

      await prisma.system_settings.upsert({
        where: { setting_key: key },
        update: { 
          setting_value: stringValue,
          updated_at: new Date()
        },
        create: {
          setting_key: key,
          setting_value: stringValue,
          setting_type: type,
          description
        }
      });

      return true;
    } catch (error) {
      console.error(`Error setting ${key}:`, error);
      return false;
    }
  }

  static async getMultipleSettings(keys) {
    try {
      const settings = await prisma.system_settings.findMany({
        where: {
          setting_key: { in: keys }
        }
      });

      const result = {};
      settings.forEach(setting => {
        let value = setting.setting_value;
        
        switch (setting.setting_type) {
          case 'number':
            value = parseFloat(value);
            break;
          case 'boolean':
            value = value === 'true';
            break;
          case 'json':
            try {
              value = JSON.parse(value);
            } catch {
              // Keep as string if JSON parse fails
            }
            break;
        }

        result[setting.setting_key] = value;
      });

      return result;
    } catch (error) {
      console.error('Error getting multiple settings:', error);
      return {};
    }
  }

  static async isFeatureEnabled(flagKey, userId = null, userType = null) {
    try {
      const flag = await prisma.feature_flags.findUnique({
        where: { flag_key: flagKey }
      });

      if (!flag || !flag.is_enabled) {
        return false;
      }

      // Check rollout percentage
      if (flag.rollout_percentage < 100) {
        const userHash = userId ? 
          userId.toString().split('').reduce((a, b) => {
            a = ((a << 5) - a) + b.charCodeAt(0);
            return a & a;
          }, 0) : Math.random() * 100;
        
        if (Math.abs(userHash) % 100 >= flag.rollout_percentage) {
          return false;
        }
      }

      // Check user type targeting
      if (flag.target_user_types && userType) {
        const targetTypes = Array.isArray(flag.target_user_types) 
          ? flag.target_user_types 
          : JSON.parse(flag.target_user_types);
        
        if (!targetTypes.includes(userType)) {
          return false;
        }
      }

      return true;
    } catch (error) {
      console.error('Feature flag check error:', error);
      return false;
    }
  }

  static async validateSystemHealth() {
    try {
      // Test database connection
      await prisma.$queryRaw`SELECT 1`;
      
      // Check recent error rates
      const recentErrors = await prisma.system_error_logs.count({
        where: {
          created_at: {
            gte: new Date(Date.now() - 60 * 60 * 1000) // Last hour
          },
          error_level: {
            in: ['error', 'critical']
          }
        }
      });

      // Check performance metrics
      const recentPerformance = await prisma.performance_logs.findMany({
        where: {
          created_at: {
            gte: new Date(Date.now() - 60 * 60 * 1000)
          }
        },
        select: {
          response_time_ms: true
        }
      });

      const avgResponseTime = recentPerformance.length > 0 
        ? recentPerformance.reduce((sum, p) => sum + p.response_time_ms, 0) / recentPerformance.length
        : 0;

      return {
        database: 'healthy',
        error_count: recentErrors,
        avg_response_time: Math.round(avgResponseTime),
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('Health check failed:', error);
      return {
        database: 'unhealthy',
        error_count: -1,
        avg_response_time: -1,
        timestamp: new Date().toISOString()
      };
    }
  }
}

module.exports = SystemSettingsUtil;




src/app.ts
import express, { Application } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import path from 'path';
import dotenv from 'dotenv';
import { startQuestScheduler } from './schedulers/questScheduler';
dotenv.config();

const { PrismaClient } = require('@prisma/client');
const { performanceMonitor, logSystemError } = require('./middleware/adminLogger');
const app: Application = express();
const PORT = process.env.PORT || 5000;
const prisma = new PrismaClient();

// Import after app is created
import { testConnection } from './config/database';
import routes from './routes';
import { errorHandler } from './middleware/errorHandler';
import { startAllSchedulers } from './schedulers/questScheduler';

// Middleware
app.use(helmet({
  crossOriginResourcePolicy: { policy: "cross-origin" }
}));

// Enhanced CORS configuration
app.use(cors({
  origin: [
    process.env.CLIENT_URL || 'http://localhost:3000',
    'http://localhost:3000',
    'http://127.0.0.1:3000',
    'http://localhost:3001'
  ],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  exposedHeaders: ['Content-Length', 'Content-Type']
}));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// SINGLE uploads middleware with proper CORS headers
app.use('/uploads', (req, res, next) => {
  res.header('Access-Control-Allow-Origin', process.env.CLIENT_URL || 'http://localhost:3000');
  res.header('Access-Control-Allow-Credentials', 'true');
  res.header('Access-Control-Allow-Methods', 'GET');
  res.header('Cross-Origin-Resource-Policy', 'cross-origin');
  next();
});

app.use(
  "/uploads",
  express.static(path.join(__dirname, "../uploads"), {
    setHeaders: (res, filePath) => {
      res.setHeader('Cache-Control', 'public, max-age=31536000');
    }
  })
);

console.log("Serving uploads from:", path.join(__dirname, "../uploads"));

// Performance monitoring middleware
app.use(async (req, res, next) => {
  try {
    const performanceEnabled = await prisma.system_settings.findUnique({
      where: { setting_key: 'performance_monitoring_enabled' }
    });
    
    if (performanceEnabled && performanceEnabled.setting_value === 'true') {
      return performanceMonitor(req, res, next);
    }
    
    next();
  } catch (error) {
    // If we can't check the setting, just continue without monitoring
    next();
  }
});

// Routes - Register ALL routes through the main router
app.use('/api', routes);

// Global error handler with system error logging
app.use(async (err: any, req: any, res: any, next: any) => {
  console.error('Global error handler:', err);

  // Log system error
  try {
    await logSystemError(err, req, req.user?.user_id);
  } catch (logError) {
    console.error('Failed to log system error:', logError);
  }

  // Determine error response based on environment
  const isDevelopment = process.env.NODE_ENV === 'development';
  
  res.status(err.status || 500).json({
    success: false,
    error: isDevelopment ? err.message : 'Internal server error',
    ...(isDevelopment && { stack: err.stack })
  });
});

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('Shutting down gracefully...');
  await prisma.$disconnect();
  process.exit(0);
});

// Error handler
app.use(errorHandler);

// Start server
const startServer = async () => {
  try {
    const dbConnected = await testConnection();
    
    if (!dbConnected) {
      console.log('⚠️ Starting server without database connection');
      console.log('🔧 Check your .env file and MySQL server');
    } else {
      console.log('✅ Database connected successfully');
      
      // 🎯 START AUTOMATIC QUEST GENERATION SYSTEM
      startAllSchedulers();
    }
    
    app.listen(PORT, () => {
      console.log(`🚀 Server running on port ${PORT}`);
      console.log(`🔗 Health check: http://localhost:${PORT}/api/health`);
      console.log('🎮 Solo Leveling Life System - Quest Generation Active!');
    });
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
};

startServer();

export default app;






upload/profile
(empty)

upload/temp
(empty)

.env
DB_HOST=127.0.0.1
DB_PORT=3306
DB_USER=root
DB_PASSWORD=password123
DB_NAME=solo_leveling_system
JWT_SECRET=your_secret_key_123456
PORT=5000
NODE_ENV=development
CLIENT_URL=http://localhost:3000
BASE_URL=http://localhost:5000

# This was inserted by `prisma init`:
# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

DATABASE_URL="mysql://johndoe:randompassword@localhost:3306/mydb"
DATABASE_URL="mysql://root:password123@127.0.0.1:3306/solo_leveling_system"


.gitignore
node_modules/
.env
dist/
uploads/*
!uploads/.gitkeep
*.log
.DS_Store
/src/generated/prisma


api.test.http
### Health Check
GET http://localhost:5000/api/health

### Signup Adventurer
POST http://localhost:5000/api/auth/signup
Content-Type: application/json

{
  "email": "test@example.com",
  "username": "testuser",
  "password": "password123",
  "user_type": "adventurer",
  "full_name": "Test User",
  "field_of_interest": "Programming Skills",
  "commitment_level": "1_hour",
  "experience_level": "beginner"
}

### Login
POST http://localhost:5000/api/auth/login
Content-Type: application/json

{
  "email": "test@example.com",
  "password": "password123"
}

### Get Daily Quests (need token from login)
GET http://localhost:5000/api/quests/daily
Authorization: Bearer YOUR_TOKEN_HERE

### Signup Coach
POST http://localhost:5000/api/auth/signup
Content-Type: application/json

{
  "email": "coach@example.com",
  "username": "coach1",
  "password": "password123",
  "user_type": "coach",
  "full_name": "Coach Name",
  "field_of_interest": "Programming Skills"
}


nodemon.json
{
  "watch": ["src"],
  "ext": "ts,js",
  "ignore": ["src/**/*.spec.ts", "node_modules"],
  "exec": "ts-node ./src/app.ts",
  "env": {
    "NODE_ENV": "development"
  }
}


package-lock.json
{
  "name": "solo-leveling-backend",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "solo-leveling-backend",
      "version": "1.0.0",
      "dependencies": {
        "@prisma/client": "^6.16.2",
        "bcrypt": "^5.1.1",
        "cors": "^2.8.5",
        "dotenv": "^16.6.1",
        "express": "^4.21.2",
        "express-rate-limit": "^6.11.2",
        "helmet": "^7.2.0",
        "jsonwebtoken": "^9.0.2",
        "multer": "^1.4.5-lts.1",
        "mysql2": "^3.14.3",
        "node-cron": "^3.0.3",
        "prisma": "^6.16.2"
      },
      "devDependencies": {
        "@types/bcrypt": "^5.0.2",
        "@types/cors": "^2.8.19",
        "@types/express": "^4.17.23",
        "@types/jsonwebtoken": "^9.0.10",
        "@types/multer": "^1.4.13",
        "@types/node": "^20.19.17",
        "nodemon": "^3.1.10",
        "ts-node": "^10.9.2",
        "typescript": "^5.9.2"
      }
    },
    "node_modules/@cspotcode/source-map-support": {
      "version": "0.8.1",
      "resolved": "https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz",
      "integrity": "sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/trace-mapping": "0.3.9"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz",
      "integrity": "sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.0.3",
        "@jridgewell/sourcemap-codec": "^1.4.10"
      }
    },
    "node_modules/@mapbox/node-pre-gyp": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@mapbox/node-pre-gyp/-/node-pre-gyp-1.0.11.tgz",
      "integrity": "sha512-Yhlar6v9WQgUp/He7BdgzOz8lqMQ8sU+jkCq7Wx8Myc5YFJLbEe7lgui/V7G1qB1DJykHSGwreceSaD60Y0PUQ==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "detect-libc": "^2.0.0",
        "https-proxy-agent": "^5.0.0",
        "make-dir": "^3.1.0",
        "node-fetch": "^2.6.7",
        "nopt": "^5.0.0",
        "npmlog": "^5.0.1",
        "rimraf": "^3.0.2",
        "semver": "^7.3.5",
        "tar": "^6.1.11"
      },
      "bin": {
        "node-pre-gyp": "bin/node-pre-gyp"
      }
    },
    "node_modules/@prisma/client": {
      "version": "6.16.2",
      "resolved": "https://registry.npmjs.org/@prisma/client/-/client-6.16.2.tgz",
      "integrity": "sha512-E00PxBcalMfYO/TWnXobBVUai6eW/g5OsifWQsQDzJYm7yaY+IRLo7ZLsaefi0QkTpxfuhFcQ/w180i6kX3iJw==",
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "peerDependencies": {
        "prisma": "*",
        "typescript": ">=5.1.0"
      },
      "peerDependenciesMeta": {
        "prisma": {
          "optional": true
        },
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@prisma/config": {
      "version": "6.16.2",
      "resolved": "https://registry.npmjs.org/@prisma/config/-/config-6.16.2.tgz",
      "integrity": "sha512-mKXSUrcqXj0LXWPmJsK2s3p9PN+aoAbyMx7m5E1v1FufofR1ZpPoIArjjzOIm+bJRLLvYftoNYLx1tbHgF9/yg==",
      "license": "Apache-2.0",
      "dependencies": {
        "c12": "3.1.0",
        "deepmerge-ts": "7.1.5",
        "effect": "3.16.12",
        "empathic": "2.0.0"
      }
    },
    "node_modules/@prisma/debug": {
      "version": "6.16.2",
      "resolved": "https://registry.npmjs.org/@prisma/debug/-/debug-6.16.2.tgz",
      "integrity": "sha512-bo4/gA/HVV6u8YK2uY6glhNsJ7r+k/i5iQ9ny/3q5bt9ijCj7WMPUwfTKPvtEgLP+/r26Z686ly11hhcLiQ8zA==",
      "license": "Apache-2.0"
    },
    "node_modules/@prisma/engines": {
      "version": "6.16.2",
      "resolved": "https://registry.npmjs.org/@prisma/engines/-/engines-6.16.2.tgz",
      "integrity": "sha512-7yf3AjfPUgsg/l7JSu1iEhsmZZ/YE00yURPjTikqm2z4btM0bCl2coFtTGfeSOWbQMmq45Jab+53yGUIAT1sjA==",
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.16.2",
        "@prisma/engines-version": "6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43",
        "@prisma/fetch-engine": "6.16.2",
        "@prisma/get-platform": "6.16.2"
      }
    },
    "node_modules/@prisma/engines-version": {
      "version": "6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43",
      "resolved": "https://registry.npmjs.org/@prisma/engines-version/-/engines-version-6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43.tgz",
      "integrity": "sha512-ThvlDaKIVrnrv97ujNFDYiQbeMQpLa0O86HFA2mNoip4mtFqM7U5GSz2ie1i2xByZtvPztJlNRgPsXGeM/kqAA==",
      "license": "Apache-2.0"
    },
    "node_modules/@prisma/fetch-engine": {
      "version": "6.16.2",
      "resolved": "https://registry.npmjs.org/@prisma/fetch-engine/-/fetch-engine-6.16.2.tgz",
      "integrity": "sha512-wPnZ8DMRqpgzye758ZvfAMiNJRuYpz+rhgEBZi60ZqDIgOU2694oJxiuu3GKFeYeR/hXxso4/2oBC243t/whxQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.16.2",
        "@prisma/engines-version": "6.16.0-7.1c57fdcd7e44b29b9313256c76699e91c3ac3c43",
        "@prisma/get-platform": "6.16.2"
      }
    },
    "node_modules/@prisma/get-platform": {
      "version": "6.16.2",
      "resolved": "https://registry.npmjs.org/@prisma/get-platform/-/get-platform-6.16.2.tgz",
      "integrity": "sha512-U/P36Uke5wS7r1+omtAgJpEB94tlT4SdlgaeTc6HVTTT93pXj7zZ+B/cZnmnvjcNPfWddgoDx8RLjmQwqGDYyA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.16.2"
      }
    },
    "node_modules/@standard-schema/spec": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/@standard-schema/spec/-/spec-1.0.0.tgz",
      "integrity": "sha512-m2bOd0f2RT9k8QJx1JN85cZYyH1RqFBdlwtkSlf4tBDYLCiiZnv1fIIwacK6cqwXavOydf0NPToMQgpKq+dVlA==",
      "license": "MIT"
    },
    "node_modules/@tsconfig/node10": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node10/-/node10-1.0.11.tgz",
      "integrity": "sha512-DcRjDCujK/kCk/cUe8Xz8ZSpm8mS3mNNpta+jGCA6USEDfktlNvm1+IuZ9eTcDbNk41BHwpHHeW+N1lKCz4zOw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node12": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node12/-/node12-1.0.11.tgz",
      "integrity": "sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node14": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@tsconfig/node14/-/node14-1.0.3.tgz",
      "integrity": "sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node16": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/@tsconfig/node16/-/node16-1.0.4.tgz",
      "integrity": "sha512-vxhUy4J8lyeyinH7Azl1pdd43GJhZH/tP2weN8TntQblOY+A0XbT8DJk1/oCPuOOyg/Ja757rG0CgHcWC8OfMA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/bcrypt": {
      "version": "5.0.2",
      "resolved": "https://registry.npmjs.org/@types/bcrypt/-/bcrypt-5.0.2.tgz",
      "integrity": "sha512-6atioO8Y75fNcbmj0G7UjI9lXN2pQ/IGJ2FWT4a/btd0Lk9lQalHLKhkgKVZ3r+spnmWUKfbMi1GEe9wyHQfNQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/body-parser": {
      "version": "1.19.6",
      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.6.tgz",
      "integrity": "sha512-HLFeCYgz89uk22N5Qg3dvGvsv46B8GLvKKo1zKG4NybA8U2DiEO3w9lqGg29t/tfLRJpJ6iQxnVw4OnB7MoM9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/connect": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/connect": {
      "version": "3.4.38",
      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.38.tgz",
      "integrity": "sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/cors": {
      "version": "2.8.19",
      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.19.tgz",
      "integrity": "sha512-mFNylyeyqN93lfe/9CSxOGREz8cpzAhH+E93xJ4xWQf62V8sQ/24reV2nyzUWM6H6Xji+GGHpkbLe7pVoUEskg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/express": {
      "version": "4.17.23",
      "resolved": "https://registry.npmjs.org/@types/express/-/express-4.17.23.tgz",
      "integrity": "sha512-Crp6WY9aTYP3qPi2wGDo9iUe/rceX01UMhnF1jmwDcKCFM6cx7YhGP/Mpr3y9AASpfHixIG0E6azCcL5OcDHsQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/body-parser": "*",
        "@types/express-serve-static-core": "^4.17.33",
        "@types/qs": "*",
        "@types/serve-static": "*"
      }
    },
    "node_modules/@types/express-serve-static-core": {
      "version": "4.19.6",
      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-4.19.6.tgz",
      "integrity": "sha512-N4LZ2xG7DatVqhCZzOGb1Yi5lMbXSZcmdLDe9EzSndPV2HpWYWzRbaerl2n27irrm94EPpprqa8KpskPT085+A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*",
        "@types/qs": "*",
        "@types/range-parser": "*",
        "@types/send": "*"
      }
    },
    "node_modules/@types/http-errors": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@types/http-errors/-/http-errors-2.0.5.tgz",
      "integrity": "sha512-r8Tayk8HJnX0FztbZN7oVqGccWgw98T/0neJphO91KkmOzug1KkofZURD4UaD5uH8AqcFLfdPErnBod0u71/qg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/jsonwebtoken": {
      "version": "9.0.10",
      "resolved": "https://registry.npmjs.org/@types/jsonwebtoken/-/jsonwebtoken-9.0.10.tgz",
      "integrity": "sha512-asx5hIG9Qmf/1oStypjanR7iKTv0gXQ1Ov/jfrX6kS/EO0OFni8orbmGCn0672NHR3kXHwpAwR+B368ZGN/2rA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/ms": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/mime": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/@types/mime/-/mime-1.3.5.tgz",
      "integrity": "sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/ms": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/@types/ms/-/ms-2.1.0.tgz",
      "integrity": "sha512-GsCCIZDE/p3i96vtEqx+7dBUGXrc7zeSK3wwPHIaRThS+9OhWIXRqzs4d6k1SVU8g91DrNRWxWUGhp5KXQb2VA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/multer": {
      "version": "1.4.13",
      "resolved": "https://registry.npmjs.org/@types/multer/-/multer-1.4.13.tgz",
      "integrity": "sha512-bhhdtPw7JqCiEfC9Jimx5LqX9BDIPJEh2q/fQ4bqbBPtyEZYr3cvF22NwG0DmPZNYA0CAf2CnqDB4KIGGpJcaw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/express": "*"
      }
    },
    "node_modules/@types/node": {
      "version": "20.19.17",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-20.19.17.tgz",
      "integrity": "sha512-gfehUI8N1z92kygssiuWvLiwcbOB3IRktR6hTDgJlXMYh5OvkPSRmgfoBUmfZt+vhwJtX7v1Yw4KvvAf7c5QKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-eOunJqu0K1923aExK6y8p6fsihYEn/BYuQ4g0CxAAgFc4b/ZLN4CrsRZ55srTdqoiLzU2B2evC+apEIxprEzkQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/range-parser": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.7.tgz",
      "integrity": "sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/send": {
      "version": "0.17.5",
      "resolved": "https://registry.npmjs.org/@types/send/-/send-0.17.5.tgz",
      "integrity": "sha512-z6F2D3cOStZvuk2SaP6YrwkNO65iTZcwA2ZkSABegdkAh/lf+Aa/YQndZVfmEXT5vgAp6zv06VQ3ejSVjAny4w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/mime": "^1",
        "@types/node": "*"
      }
    },
    "node_modules/@types/serve-static": {
      "version": "1.15.8",
      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.8.tgz",
      "integrity": "sha512-roei0UY3LhpOJvjbIP6ZZFngyLKl5dskOtDhxY5THRSpO+ZI+nzJ+m5yUMzGrp89YRa7lvknKkMYjqQFGwA7Sg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/http-errors": "*",
        "@types/node": "*",
        "@types/send": "*"
      }
    },
    "node_modules/abbrev": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/abbrev/-/abbrev-1.1.1.tgz",
      "integrity": "sha512-nne9/IiQ/hzIhY6pdDnbBtz7DjPTKrY00P/zvPSm5pOFkl6xuGrGnXn/VtTNNfNtAfZ9/1RtehkszU9qcTii0Q==",
      "license": "ISC"
    },
    "node_modules/accepts": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
      "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
      "license": "MIT",
      "dependencies": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/acorn": {
      "version": "8.15.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
      "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-walk": {
      "version": "8.3.4",
      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.3.4.tgz",
      "integrity": "sha512-ueEepnujpqee2o5aIYnvHU6C0A42MNdsIDeqy5BydrkuC5R1ZuUFnm27EeFJGoEHJQgn3uleRvmTXaJgfXbt4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "acorn": "^8.11.0"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/agent-base": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-6.0.2.tgz",
      "integrity": "sha512-RZNwNclF7+MS/8bDg70amg32dyeZGZxiDuQmZxKLAlQjr3jGyLx+4Kkk58UO7D2QdgFIQCovuSuZESne6RG6XQ==",
      "license": "MIT",
      "dependencies": {
        "debug": "4"
      },
      "engines": {
        "node": ">= 6.0.0"
      }
    },
    "node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/append-field": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/append-field/-/append-field-1.0.0.tgz",
      "integrity": "sha512-klpgFSWLW1ZEs8svjfb7g4qWY0YS5imI82dTg+QahUvJ8YqAY0P10Uk8tTyh9ZGuYEZEMaeJYCF5BFuX552hsw==",
      "license": "MIT"
    },
    "node_modules/aproba": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/aproba/-/aproba-2.1.0.tgz",
      "integrity": "sha512-tLIEcj5GuR2RSTnxNKdkK0dJ/GrC7P38sUkiDmDuHfsHmbagTFAxDVIBltoklXEVIQ/f14IL8IMJ5pn9Hez1Ew==",
      "license": "ISC"
    },
    "node_modules/are-we-there-yet": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/are-we-there-yet/-/are-we-there-yet-2.0.0.tgz",
      "integrity": "sha512-Ci/qENmwHnsYo9xKIcUJN5LeDKdJ6R1Z1j9V/J5wyq8nh/mYPEpIKJbBZXtZjG04HiK7zV/p6Vs9952MrMeUIw==",
      "deprecated": "This package is no longer supported.",
      "license": "ISC",
      "dependencies": {
        "delegates": "^1.0.0",
        "readable-stream": "^3.6.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/are-we-there-yet/node_modules/readable-stream": {
      "version": "3.6.2",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz",
      "integrity": "sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==",
      "license": "MIT",
      "dependencies": {
        "inherits": "^2.0.3",
        "string_decoder": "^1.1.1",
        "util-deprecate": "^1.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/arg": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/arg/-/arg-4.1.3.tgz",
      "integrity": "sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/array-flatten": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
      "integrity": "sha512-PCVAQswWemu6UdxsDFFX/+gVeYqKAod3D3UVm91jHwynguOwAvYPhx8nNlM++NqRcK6CxxpUafjmhIdKiHibqg==",
      "license": "MIT"
    },
    "node_modules/aws-ssl-profiles": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/aws-ssl-profiles/-/aws-ssl-profiles-1.1.2.tgz",
      "integrity": "sha512-NZKeq9AfyQvEeNlN0zSYAaWrmBffJh3IELMZfRpJVWgrpEbtEpnjvzqBPf+mxoI287JohRDoa+/nsfqqiZmF6g==",
      "license": "MIT",
      "engines": {
        "node": ">= 6.0.0"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "license": "MIT"
    },
    "node_modules/bcrypt": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/bcrypt/-/bcrypt-5.1.1.tgz",
      "integrity": "sha512-AGBHOG5hPYZ5Xl9KXzU5iKq9516yEmvCKDg3ecP5kX2aB6UqTeXZxk2ELnDgDm6BQSMlLt9rDB4LoSMx0rYwww==",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "@mapbox/node-pre-gyp": "^1.0.11",
        "node-addon-api": "^5.0.0"
      },
      "engines": {
        "node": ">= 10.0.0"
      }
    },
    "node_modules/binary-extensions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/body-parser": {
      "version": "1.20.3",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.3.tgz",
      "integrity": "sha512-7rAxByjUMqQ3/bHJy7D6OGXvx/MMc4IqBn/X0fcM1QUcAItpZrBEYhWGem+tzXH90c+G01ypMcYJBO9Y30203g==",
      "license": "MIT",
      "dependencies": {
        "bytes": "3.1.2",
        "content-type": "~1.0.5",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "on-finished": "2.4.1",
        "qs": "6.13.0",
        "raw-body": "2.5.2",
        "type-is": "~1.6.18",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/body-parser/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/body-parser/node_modules/iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/body-parser/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==",
      "license": "BSD-3-Clause"
    },
    "node_modules/buffer-from": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz",
      "integrity": "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==",
      "license": "MIT"
    },
    "node_modules/busboy": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/busboy/-/busboy-1.6.0.tgz",
      "integrity": "sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==",
      "dependencies": {
        "streamsearch": "^1.1.0"
      },
      "engines": {
        "node": ">=10.16.0"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/c12": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/c12/-/c12-3.1.0.tgz",
      "integrity": "sha512-uWoS8OU1MEIsOv8p/5a82c3H31LsWVR5qiyXVfBNOzfffjUWtPnhAb4BYI2uG2HfGmZmFjCtui5XNWaps+iFuw==",
      "license": "MIT",
      "dependencies": {
        "chokidar": "^4.0.3",
        "confbox": "^0.2.2",
        "defu": "^6.1.4",
        "dotenv": "^16.6.1",
        "exsolve": "^1.0.7",
        "giget": "^2.0.0",
        "jiti": "^2.4.2",
        "ohash": "^2.0.11",
        "pathe": "^2.0.3",
        "perfect-debounce": "^1.0.0",
        "pkg-types": "^2.2.0",
        "rc9": "^2.1.2"
      },
      "peerDependencies": {
        "magicast": "^0.3.5"
      },
      "peerDependenciesMeta": {
        "magicast": {
          "optional": true
        }
      }
    },
    "node_modules/c12/node_modules/chokidar": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-4.0.3.tgz",
      "integrity": "sha512-Qgzu8kfBvo+cA4962jnP1KkS6Dop5NS6g7R5LFYJr4b8Ub94PPQXUksCw9PvXoeXPRRddRNC5C1JQUR2SMGtnA==",
      "license": "MIT",
      "dependencies": {
        "readdirp": "^4.0.1"
      },
      "engines": {
        "node": ">= 14.16.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      }
    },
    "node_modules/c12/node_modules/readdirp": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-4.1.2.tgz",
      "integrity": "sha512-GDhwkLfywWL2s6vEjyhri+eXmfH6j1L7JE27WhqLeYzoh/A3DBaYGEj2H/HFZCn/kMfim73FXxEJTw06WtxQwg==",
      "license": "MIT",
      "engines": {
        "node": ">= 14.18.0"
      },
      "funding": {
        "type": "individual",
        "url": "https://paulmillr.com/funding/"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/chokidar": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/chownr": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/chownr/-/chownr-2.0.0.tgz",
      "integrity": "sha512-bIomtDF5KGpdogkLd9VspvFzk9KfpyyGlS8YFVZl7TGPBHL5snIOnxeshwVgPteQ9b4Eydl+pVbIyE1DcvCWgQ==",
      "license": "ISC",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/citty": {
      "version": "0.1.6",
      "resolved": "https://registry.npmjs.org/citty/-/citty-0.1.6.tgz",
      "integrity": "sha512-tskPPKEs8D2KPafUypv2gxwJP8h/OaJmC82QQGGDQcHvXX43xF2VDACcJVmZ0EuSxkpO9Kc4MlrA3q0+FG58AQ==",
      "license": "MIT",
      "dependencies": {
        "consola": "^3.2.3"
      }
    },
    "node_modules/color-support": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/color-support/-/color-support-1.1.3.tgz",
      "integrity": "sha512-qiBjkpbMLO/HL68y+lh4q0/O1MZFj2RX6X/KmMa3+gJD3z+WwI1ZzDHysvqHGS3mP6mznPckpXmw1nI9cJjyRg==",
      "license": "ISC",
      "bin": {
        "color-support": "bin.js"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "license": "MIT"
    },
    "node_modules/concat-stream": {
      "version": "1.6.2",
      "resolved": "https://registry.npmjs.org/concat-stream/-/concat-stream-1.6.2.tgz",
      "integrity": "sha512-27HBghJxjiZtIk3Ycvn/4kbJk/1uZuJFfuPEns6LaEvpvG1f0hTea8lilrouyo9mVc2GWdcEZ8OLoGmSADlrCw==",
      "engines": [
        "node >= 0.8"
      ],
      "license": "MIT",
      "dependencies": {
        "buffer-from": "^1.0.0",
        "inherits": "^2.0.3",
        "readable-stream": "^2.2.2",
        "typedarray": "^0.0.6"
      }
    },
    "node_modules/confbox": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/confbox/-/confbox-0.2.2.tgz",
      "integrity": "sha512-1NB+BKqhtNipMsov4xI/NnhCKp9XG9NamYp5PVm9klAT0fsrNPjaFICsCFhNhwZJKNh7zB/3q8qXz0E9oaMNtQ==",
      "license": "MIT"
    },
    "node_modules/consola": {
      "version": "3.4.2",
      "resolved": "https://registry.npmjs.org/consola/-/consola-3.4.2.tgz",
      "integrity": "sha512-5IKcdX0nnYavi6G7TtOhwkYzyjfJlatbjMjuLSfE2kYT5pMDOilZ4OvMhi637CcDICTmz3wARPoyhqyX1Y+XvA==",
      "license": "MIT",
      "engines": {
        "node": "^14.18.0 || >=16.10.0"
      }
    },
    "node_modules/console-control-strings": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/console-control-strings/-/console-control-strings-1.1.0.tgz",
      "integrity": "sha512-ty/fTekppD2fIwRvnZAVdeOiGd1c7YXEixbgJTNzqcxJWKQnjJ/V1bNEEE6hygpM3WjwHFUVK6HTjWSzV4a8sQ==",
      "license": "ISC"
    },
    "node_modules/content-disposition": {
      "version": "0.5.4",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.4.tgz",
      "integrity": "sha512-FveZTNuGw04cxlAiWbzi6zTAL/lhehaWbTtgluJh4/E95DqMwTmha3KZN1aAWA8cFIhHzMZUvLevkw5Rqk+tSQ==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.7.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.1.tgz",
      "integrity": "sha512-6DnInpx7SJ2AK3+CTUE/ZM0vWTUboZCegxhC2xiIydHR9jNuTAASBrfEpHhiGOZw/nX51bHt6YQl8jsGo4y/0w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
      "integrity": "sha512-QADzlaHc8icV8I7vbaJXJwod9HWYp8uCqf1xa4OfNu1T7JVxQIrUgOWtHdNDtPiywmFbiS12VjotIXLrKM3orQ==",
      "license": "MIT"
    },
    "node_modules/core-util-is": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.3.tgz",
      "integrity": "sha512-ZQBvi1DcpJ4GDqanjucZ2Hj3wEO5pZDS89BWbkcrvdxksJorwUDDZamX9ldFkp9aw2lmBDLgkObEA4DWNJ9FYQ==",
      "license": "MIT"
    },
    "node_modules/cors": {
      "version": "2.8.5",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
      "license": "MIT",
      "dependencies": {
        "object-assign": "^4",
        "vary": "^1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/create-require": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz",
      "integrity": "sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/deepmerge-ts": {
      "version": "7.1.5",
      "resolved": "https://registry.npmjs.org/deepmerge-ts/-/deepmerge-ts-7.1.5.tgz",
      "integrity": "sha512-HOJkrhaYsweh+W+e74Yn7YStZOilkoPb6fycpwNLKzSPtruFs48nYis0zy5yJz1+ktUhHxoRDJ27RQAWLIJVJw==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/defu": {
      "version": "6.1.4",
      "resolved": "https://registry.npmjs.org/defu/-/defu-6.1.4.tgz",
      "integrity": "sha512-mEQCMmwJu317oSz8CwdIOdwf3xMif1ttiM8LTufzc3g6kR+9Pe236twL8j3IYT1F7GfRgGcW6MWxzZjLIkuHIg==",
      "license": "MIT"
    },
    "node_modules/delegates": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delegates/-/delegates-1.0.0.tgz",
      "integrity": "sha512-bd2L678uiWATM6m5Z1VzNCErI3jiGzt6HGY8OVICs40JQq/HALfbyNJmp0UDakEY4pMMaN0Ly5om/B1VI/+xfQ==",
      "license": "MIT"
    },
    "node_modules/denque": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/denque/-/denque-2.1.0.tgz",
      "integrity": "sha512-HVQE3AAb/pxF8fQAoiqpvg9i3evqug3hoiwakOyZAwJm+6vZehbkYXZ0l4JxS+I3QxM97v5aaRNhj8v5oBhekw==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/destr": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/destr/-/destr-2.0.5.tgz",
      "integrity": "sha512-ugFTXCtDZunbzasqBxrK93Ik/DRYsO6S/fedkWEMKqt04xZ4csmnmwGDBAb07QWNaGMAmnTIemsYZCksjATwsA==",
      "license": "MIT"
    },
    "node_modules/destroy": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz",
      "integrity": "sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/detect-libc": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/detect-libc/-/detect-libc-2.0.4.tgz",
      "integrity": "sha512-3UDv+G9CsCKO1WKMGw9fwq/SWJYbI0c5Y7LU1AXYoDdbhE2AHQ6N6Nb34sG8Fj7T5APy8qXDCKuuIHd1BR0tVA==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/diff": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.2.tgz",
      "integrity": "sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.3.1"
      }
    },
    "node_modules/dotenv": {
      "version": "16.6.1",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-16.6.1.tgz",
      "integrity": "sha512-uBq4egWHTcTt33a72vpSG0z3HnPuIl6NqYcTrKEg2azoEyl2hpW0zqlxysq2pK9HlDIHyHyakeYaYnSAwd8bow==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
      "license": "MIT"
    },
    "node_modules/effect": {
      "version": "3.16.12",
      "resolved": "https://registry.npmjs.org/effect/-/effect-3.16.12.tgz",
      "integrity": "sha512-N39iBk0K71F9nb442TLbTkjl24FLUzuvx2i1I2RsEAQsdAdUTuUoW0vlfUXgkMTUOnYqKnWcFfqw4hK4Pw27hg==",
      "license": "MIT",
      "dependencies": {
        "@standard-schema/spec": "^1.0.0",
        "fast-check": "^3.23.1"
      }
    },
    "node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "license": "MIT"
    },
    "node_modules/empathic": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/empathic/-/empathic-2.0.0.tgz",
      "integrity": "sha512-i6UzDscO/XfAcNYD75CfICkmfLedpyPDdozrLMmQc5ORaQcdMoc21OnlEylMIqI7U8eniKrPMxxtj8k0vhmJhA==",
      "license": "MIT",
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
      "license": "MIT"
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/express": {
      "version": "4.21.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.21.2.tgz",
      "integrity": "sha512-28HqgMZAmih1Czt9ny7qr6ek2qddF4FclbMzwhCREB6OFfH+rXAnuNCwo1/wFvrtbgsQDb4kSbX9de9lFbrXnA==",
      "license": "MIT",
      "dependencies": {
        "accepts": "~1.3.8",
        "array-flatten": "1.1.1",
        "body-parser": "1.20.3",
        "content-disposition": "0.5.4",
        "content-type": "~1.0.4",
        "cookie": "0.7.1",
        "cookie-signature": "1.0.6",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "finalhandler": "1.3.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "merge-descriptors": "1.0.3",
        "methods": "~1.1.2",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "path-to-regexp": "0.1.12",
        "proxy-addr": "~2.0.7",
        "qs": "6.13.0",
        "range-parser": "~1.2.1",
        "safe-buffer": "5.2.1",
        "send": "0.19.0",
        "serve-static": "1.16.2",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "type-is": "~1.6.18",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "engines": {
        "node": ">= 0.10.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/express-rate-limit": {
      "version": "6.11.2",
      "resolved": "https://registry.npmjs.org/express-rate-limit/-/express-rate-limit-6.11.2.tgz",
      "integrity": "sha512-a7uwwfNTh1U60ssiIkuLFWHt4hAC5yxlLGU2VP0X4YNlyEDZAqF4tK3GD3NSitVBrCQmQ0++0uOyFOgC2y4DDw==",
      "license": "MIT",
      "engines": {
        "node": ">= 14"
      },
      "peerDependencies": {
        "express": "^4 || ^5"
      }
    },
    "node_modules/express/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/express/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/exsolve": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/exsolve/-/exsolve-1.0.7.tgz",
      "integrity": "sha512-VO5fQUzZtI6C+vx4w/4BWJpg3s/5l+6pRQEHzFRM8WFi4XffSP1Z+4qi7GbjWbvRQEbdIco5mIMq+zX4rPuLrw==",
      "license": "MIT"
    },
    "node_modules/fast-check": {
      "version": "3.23.2",
      "resolved": "https://registry.npmjs.org/fast-check/-/fast-check-3.23.2.tgz",
      "integrity": "sha512-h5+1OzzfCC3Ef7VbtKdcv7zsstUQwUDlYpUTvjeUsJAssPgLn7QzbboPtL5ro04Mq0rPOsMzl7q5hIbRs2wD1A==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/dubzzz"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/fast-check"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "pure-rand": "^6.1.0"
      },
      "engines": {
        "node": ">=8.0.0"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/finalhandler": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.3.1.tgz",
      "integrity": "sha512-6BN9trH7bp3qvnrRyzsBz+g3lZxTNZTbVO2EV1CS0WIcDbawYVdYvGflME/9QP0h0pYlCDBCTjYa9nZzMDpyxQ==",
      "license": "MIT",
      "dependencies": {
        "debug": "2.6.9",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "statuses": "2.0.1",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/finalhandler/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/finalhandler/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
      "integrity": "sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fs-minipass": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fs-minipass/-/fs-minipass-2.1.0.tgz",
      "integrity": "sha512-V/JgOLFCS+R6Vcq0slCuaeWEdNC3ouDlJMNIsacH2VtALiu9mV4LPrHc5cDl8k5aw6J8jwgWWpiTo5RYhmIzvg==",
      "license": "ISC",
      "dependencies": {
        "minipass": "^3.0.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/fs-minipass/node_modules/minipass": {
      "version": "3.3.6",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-3.3.6.tgz",
      "integrity": "sha512-DxiNidxSEK+tHG6zOIklvNOwm3hvCrbUrdtzY74U6HKTJxvIDfOUL5W5P2Ghd3DTkhhKPYGqeNUIh5qcM4YBfw==",
      "license": "ISC",
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==",
      "license": "ISC"
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gauge": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/gauge/-/gauge-3.0.2.tgz",
      "integrity": "sha512-+5J6MS/5XksCuXq++uFRsnUd7Ovu1XenbeuIuNRJxYWjgQbPuFhT14lAvsWfqfAmnwluf1OwMjz39HjfLPci0Q==",
      "deprecated": "This package is no longer supported.",
      "license": "ISC",
      "dependencies": {
        "aproba": "^1.0.3 || ^2.0.0",
        "color-support": "^1.1.2",
        "console-control-strings": "^1.0.0",
        "has-unicode": "^2.0.1",
        "object-assign": "^4.1.1",
        "signal-exit": "^3.0.0",
        "string-width": "^4.2.3",
        "strip-ansi": "^6.0.1",
        "wide-align": "^1.1.2"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/generate-function": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/generate-function/-/generate-function-2.3.1.tgz",
      "integrity": "sha512-eeB5GfMNeevm/GRYq20ShmsaGcmI81kIX2K9XQx5miC8KdHaC6Jm0qQ8ZNeGOi7wYB8OsdxKs+Y2oVuTFuVwKQ==",
      "license": "MIT",
      "dependencies": {
        "is-property": "^1.0.2"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/giget": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/giget/-/giget-2.0.0.tgz",
      "integrity": "sha512-L5bGsVkxJbJgdnwyuheIunkGatUF/zssUoxxjACCseZYAVbaqdh9Tsmmlkl8vYan09H7sbvKt4pS8GqKLBrEzA==",
      "license": "MIT",
      "dependencies": {
        "citty": "^0.1.6",
        "consola": "^3.4.0",
        "defu": "^6.1.4",
        "node-fetch-native": "^1.6.6",
        "nypm": "^0.6.0",
        "pathe": "^2.0.3"
      },
      "bin": {
        "giget": "dist/cli.mjs"
      }
    },
    "node_modules/glob": {
      "version": "7.2.3",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
      "deprecated": "Glob versions prior to v9 are no longer supported",
      "license": "ISC",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.1.1",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-unicode": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/has-unicode/-/has-unicode-2.0.1.tgz",
      "integrity": "sha512-8Rf9Y83NBReMnx0gFzA8JImQACstCYWUplepDa9xprwwtmgEZUF0h/i5xSA625zB/I37EtrswSST6OXxwaaIJQ==",
      "license": "ISC"
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/helmet": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/helmet/-/helmet-7.2.0.tgz",
      "integrity": "sha512-ZRiwvN089JfMXokizgqEPXsl2Guk094yExfoDXR0cBYWxtBbaSww/w+vT4WEJsBW2iTUi1GgZ6swmoug3Oy4Xw==",
      "license": "MIT",
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
      "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
      "license": "MIT",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/https-proxy-agent": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-5.0.1.tgz",
      "integrity": "sha512-dFcAjpTQFgoLMzC2VwU+C/CbS7uRL0lWmxDITmqm7C+7F0Odmj6s9l6alZc6AELXhrnggM2CeWSXHGOdX2YtwA==",
      "license": "MIT",
      "dependencies": {
        "agent-base": "6",
        "debug": "4"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
      "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/ignore-by-default": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/ignore-by-default/-/ignore-by-default-1.0.1.tgz",
      "integrity": "sha512-Ius2VYcGNk7T90CppJqcIkS5ooHUZyIQK+ClZfMfMNFEF9VSE73Fq+906u/CWu92x4gzZMWOwfFYckPObzdEbA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==",
      "deprecated": "This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.",
      "license": "ISC",
      "dependencies": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/is-property": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/is-property/-/is-property-1.0.2.tgz",
      "integrity": "sha512-Ks/IoX00TtClbGQr4TWXemAnktAQvYB7HzcCxDGqEZU6oCmb2INHuOoKxbtR+HFkmYWBKv/dOZtGRiAjDhj92g==",
      "license": "MIT"
    },
    "node_modules/isarray": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz",
      "integrity": "sha512-VLghIWNM6ELQzo7zwmcg0NmTVyWKYjvIeM83yjp0wRDTmUnrM678fQbcKBo6n2CJEF0szoG//ytg+TKla89ALQ==",
      "license": "MIT"
    },
    "node_modules/jiti": {
      "version": "2.5.1",
      "resolved": "https://registry.npmjs.org/jiti/-/jiti-2.5.1.tgz",
      "integrity": "sha512-twQoecYPiVA5K/h6SxtORw/Bs3ar+mLUtoPSc7iMXzQzK8d7eJ/R09wmTwAjiamETn1cXYPGfNnu7DMoHgu12w==",
      "license": "MIT",
      "bin": {
        "jiti": "lib/jiti-cli.mjs"
      }
    },
    "node_modules/jsonwebtoken": {
      "version": "9.0.2",
      "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-9.0.2.tgz",
      "integrity": "sha512-PRp66vJ865SSqOlgqS8hujT5U4AOgMfhrwYIuIhfKaoSCZcirrmASQr8CX7cUg+RMih+hgznrjp99o+W4pJLHQ==",
      "license": "MIT",
      "dependencies": {
        "jws": "^3.2.2",
        "lodash.includes": "^4.3.0",
        "lodash.isboolean": "^3.0.3",
        "lodash.isinteger": "^4.0.4",
        "lodash.isnumber": "^3.0.3",
        "lodash.isplainobject": "^4.0.6",
        "lodash.isstring": "^4.0.1",
        "lodash.once": "^4.0.0",
        "ms": "^2.1.1",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      }
    },
    "node_modules/jwa": {
      "version": "1.4.2",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-1.4.2.tgz",
      "integrity": "sha512-eeH5JO+21J78qMvTIDdBXidBd6nG2kZjg5Ohz/1fpa28Z4CcsWUzJ1ZZyFq/3z3N17aZy+ZuBoHljASbL1WfOw==",
      "license": "MIT",
      "dependencies": {
        "buffer-equal-constant-time": "^1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/jws/-/jws-3.2.2.tgz",
      "integrity": "sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==",
      "license": "MIT",
      "dependencies": {
        "jwa": "^1.4.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/lodash.includes": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/lodash.includes/-/lodash.includes-4.3.0.tgz",
      "integrity": "sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w==",
      "license": "MIT"
    },
    "node_modules/lodash.isboolean": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
      "integrity": "sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==",
      "license": "MIT"
    },
    "node_modules/lodash.isinteger": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/lodash.isinteger/-/lodash.isinteger-4.0.4.tgz",
      "integrity": "sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA==",
      "license": "MIT"
    },
    "node_modules/lodash.isnumber": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isnumber/-/lodash.isnumber-3.0.3.tgz",
      "integrity": "sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw==",
      "license": "MIT"
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==",
      "license": "MIT"
    },
    "node_modules/lodash.isstring": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/lodash.isstring/-/lodash.isstring-4.0.1.tgz",
      "integrity": "sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw==",
      "license": "MIT"
    },
    "node_modules/lodash.once": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/lodash.once/-/lodash.once-4.1.1.tgz",
      "integrity": "sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg==",
      "license": "MIT"
    },
    "node_modules/long": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/long/-/long-5.3.2.tgz",
      "integrity": "sha512-mNAgZ1GmyNhD7AuqnTG3/VQ26o760+ZYBPKjPvugO8+nLbYfX6TVpJPseBvopbdY+qpZ/lKUnmEc1LeZYS3QAA==",
      "license": "Apache-2.0"
    },
    "node_modules/lru-cache": {
      "version": "7.18.3",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-7.18.3.tgz",
      "integrity": "sha512-jumlc0BIUrS3qJGgIkWZsyfAM7NCWiBcCDhnd+3NNM5KbBmLTgHVfWBcg6W+rLUsIpzpERPsvwUP7CckAQSOoA==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/lru.min": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/lru.min/-/lru.min-1.1.2.tgz",
      "integrity": "sha512-Nv9KddBcQSlQopmBHXSsZVY5xsdlZkdH/Iey0BlcBYggMd4two7cZnKOK9vmy3nY0O5RGH99z1PCeTpPqszUYg==",
      "license": "MIT",
      "engines": {
        "bun": ">=1.0.0",
        "deno": ">=1.30.0",
        "node": ">=8.0.0"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/wellwelwel"
      }
    },
    "node_modules/make-dir": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-3.1.0.tgz",
      "integrity": "sha512-g3FeP20LNwhALb/6Cz6Dd4F2ngze0jz7tbzrD2wAV+o9FeNHe4rL+yK2md0J/fiSf1sa1ADhXqi5+oVwOM/eGw==",
      "license": "MIT",
      "dependencies": {
        "semver": "^6.0.0"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/make-dir/node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/make-error": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.3.tgz",
      "integrity": "sha512-gaNvAS7TZ897/rVaZ0nMtAyxNyi/pdbjbAwUpFQpN70GqnVfOiXpeUUMKRBmzXaSQ8DdTX4/0ms62r2K+hE6mQ==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
      "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/mime/-/mime-1.6.0.tgz",
      "integrity": "sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg==",
      "license": "MIT",
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/minimist": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.8.tgz",
      "integrity": "sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/minipass": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-5.0.0.tgz",
      "integrity": "sha512-3FnjYuehv9k6ovOEbyOswadCDPX1piCfhV8ncmYtHOjuPwylVWsghTLo7rabjC3Rx5xD4HDx8Wm1xnMF7S5qFQ==",
      "license": "ISC",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/minizlib": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/minizlib/-/minizlib-2.1.2.tgz",
      "integrity": "sha512-bAxsR8BVfj60DWXHE3u30oHzfl4G7khkSuPW+qvpd7jFRHm7dLxOjUk1EHACJ/hxLY8phGJ0YhYHZo7jil7Qdg==",
      "license": "MIT",
      "dependencies": {
        "minipass": "^3.0.0",
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/minizlib/node_modules/minipass": {
      "version": "3.3.6",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-3.3.6.tgz",
      "integrity": "sha512-DxiNidxSEK+tHG6zOIklvNOwm3hvCrbUrdtzY74U6HKTJxvIDfOUL5W5P2Ghd3DTkhhKPYGqeNUIh5qcM4YBfw==",
      "license": "ISC",
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/mkdirp": {
      "version": "0.5.6",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.6.tgz",
      "integrity": "sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==",
      "license": "MIT",
      "dependencies": {
        "minimist": "^1.2.6"
      },
      "bin": {
        "mkdirp": "bin/cmd.js"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/multer": {
      "version": "1.4.5-lts.2",
      "resolved": "https://registry.npmjs.org/multer/-/multer-1.4.5-lts.2.tgz",
      "integrity": "sha512-VzGiVigcG9zUAoCNU+xShztrlr1auZOlurXynNvO9GiWD1/mTBbUljOKY+qMeazBqXgRnjzeEgJI/wyjJUHg9A==",
      "deprecated": "Multer 1.x is impacted by a number of vulnerabilities, which have been patched in 2.x. You should upgrade to the latest 2.x version.",
      "license": "MIT",
      "dependencies": {
        "append-field": "^1.0.0",
        "busboy": "^1.0.0",
        "concat-stream": "^1.5.2",
        "mkdirp": "^0.5.4",
        "object-assign": "^4.1.1",
        "type-is": "^1.6.4",
        "xtend": "^4.0.0"
      },
      "engines": {
        "node": ">= 6.0.0"
      }
    },
    "node_modules/mysql2": {
      "version": "3.14.3",
      "resolved": "https://registry.npmjs.org/mysql2/-/mysql2-3.14.3.tgz",
      "integrity": "sha512-fD6MLV8XJ1KiNFIF0bS7Msl8eZyhlTDCDl75ajU5SJtpdx9ZPEACulJcqJWr1Y8OYyxsFc4j3+nflpmhxCU5aQ==",
      "license": "MIT",
      "dependencies": {
        "aws-ssl-profiles": "^1.1.1",
        "denque": "^2.1.0",
        "generate-function": "^2.3.1",
        "iconv-lite": "^0.6.3",
        "long": "^5.2.1",
        "lru.min": "^1.0.0",
        "named-placeholders": "^1.1.3",
        "seq-queue": "^0.0.5",
        "sqlstring": "^2.3.2"
      },
      "engines": {
        "node": ">= 8.0"
      }
    },
    "node_modules/named-placeholders": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/named-placeholders/-/named-placeholders-1.1.3.tgz",
      "integrity": "sha512-eLoBxg6wE/rZkJPhU/xRX1WTpkFEwDJEN96oxFrTsqBdbT5ec295Q+CoHrL9IT0DipqKhmGcaZmwOt8OON5x1w==",
      "license": "MIT",
      "dependencies": {
        "lru-cache": "^7.14.1"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/negotiator": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
      "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/node-addon-api": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/node-addon-api/-/node-addon-api-5.1.0.tgz",
      "integrity": "sha512-eh0GgfEkpnoWDq+VY8OyvYhFEzBk6jIYbRKdIlyTiAXIVJ8PyBaKb0rp7oDtoddbdoHWhq8wwr+XZ81F1rpNdA==",
      "license": "MIT"
    },
    "node_modules/node-cron": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/node-cron/-/node-cron-3.0.3.tgz",
      "integrity": "sha512-dOal67//nohNgYWb+nWmg5dkFdIwDm8EpeGYMekPMrngV3637lqnX0lbUcCtgibHTz6SEz7DAIjKvKDFYCnO1A==",
      "license": "ISC",
      "dependencies": {
        "uuid": "8.3.2"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/node-fetch": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.7.0.tgz",
      "integrity": "sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==",
      "license": "MIT",
      "dependencies": {
        "whatwg-url": "^5.0.0"
      },
      "engines": {
        "node": "4.x || >=6.0.0"
      },
      "peerDependencies": {
        "encoding": "^0.1.0"
      },
      "peerDependenciesMeta": {
        "encoding": {
          "optional": true
        }
      }
    },
    "node_modules/node-fetch-native": {
      "version": "1.6.7",
      "resolved": "https://registry.npmjs.org/node-fetch-native/-/node-fetch-native-1.6.7.tgz",
      "integrity": "sha512-g9yhqoedzIUm0nTnTqAQvueMPVOuIY16bqgAJJC8XOOubYFNwz6IER9qs0Gq2Xd0+CecCKFjtdDTMA4u4xG06Q==",
      "license": "MIT"
    },
    "node_modules/nodemon": {
      "version": "3.1.10",
      "resolved": "https://registry.npmjs.org/nodemon/-/nodemon-3.1.10.tgz",
      "integrity": "sha512-WDjw3pJ0/0jMFmyNDp3gvY2YizjLmmOUQo6DEBY+JgdvW/yQ9mEeSw6H5ythl5Ny2ytb7f9C2nIbjSxMNzbJXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chokidar": "^3.5.2",
        "debug": "^4",
        "ignore-by-default": "^1.0.1",
        "minimatch": "^3.1.2",
        "pstree.remy": "^1.1.8",
        "semver": "^7.5.3",
        "simple-update-notifier": "^2.0.0",
        "supports-color": "^5.5.0",
        "touch": "^3.1.0",
        "undefsafe": "^2.0.5"
      },
      "bin": {
        "nodemon": "bin/nodemon.js"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/nodemon"
      }
    },
    "node_modules/nopt": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/nopt/-/nopt-5.0.0.tgz",
      "integrity": "sha512-Tbj67rffqceeLpcRXrT7vKAN8CwfPeIBgM7E6iBkmKLV7bEMwpGgYLGv0jACUsECaa/vuxP0IjEont6umdMgtQ==",
      "license": "ISC",
      "dependencies": {
        "abbrev": "1"
      },
      "bin": {
        "nopt": "bin/nopt.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/npmlog": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/npmlog/-/npmlog-5.0.1.tgz",
      "integrity": "sha512-AqZtDUWOMKs1G/8lwylVjrdYgqA4d9nu8hc+0gzRxlDb1I10+FHBGMXs6aiQHFdCUUlqH99MUMuLfzWDNDtfxw==",
      "deprecated": "This package is no longer supported.",
      "license": "ISC",
      "dependencies": {
        "are-we-there-yet": "^2.0.0",
        "console-control-strings": "^1.1.0",
        "gauge": "^3.0.0",
        "set-blocking": "^2.0.0"
      }
    },
    "node_modules/nypm": {
      "version": "0.6.2",
      "resolved": "https://registry.npmjs.org/nypm/-/nypm-0.6.2.tgz",
      "integrity": "sha512-7eM+hpOtrKrBDCh7Ypu2lJ9Z7PNZBdi/8AT3AX8xoCj43BBVHD0hPSTEvMtkMpfs8FCqBGhxB+uToIQimA111g==",
      "license": "MIT",
      "dependencies": {
        "citty": "^0.1.6",
        "consola": "^3.4.2",
        "pathe": "^2.0.3",
        "pkg-types": "^2.3.0",
        "tinyexec": "^1.0.1"
      },
      "bin": {
        "nypm": "dist/cli.mjs"
      },
      "engines": {
        "node": "^14.16.0 || >=16.10.0"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/ohash": {
      "version": "2.0.11",
      "resolved": "https://registry.npmjs.org/ohash/-/ohash-2.0.11.tgz",
      "integrity": "sha512-RdR9FQrFwNBNXAr4GixM8YaRZRJ5PUWbKYbE5eOsrwAjJW0q2REGcf79oYPsLyskQCZG1PLN+S/K1V00joZAoQ==",
      "license": "MIT"
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "license": "MIT",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "0.1.12",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
      "integrity": "sha512-RA1GjUVMnvYFxuqovrEqZoxxW5NUZqbwKtYz/Tt7nXerk0LbLblQmrsgdeOxV5SFHf0UDggjS/bSeOZwt1pmEQ==",
      "license": "MIT"
    },
    "node_modules/pathe": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/pathe/-/pathe-2.0.3.tgz",
      "integrity": "sha512-WUjGcAqP1gQacoQe+OBJsFA7Ld4DyXuUIjZ5cc75cLHvJ7dtNsTugphxIADwspS+AraAUePCKrSVtPLFj/F88w==",
      "license": "MIT"
    },
    "node_modules/perfect-debounce": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/perfect-debounce/-/perfect-debounce-1.0.0.tgz",
      "integrity": "sha512-xCy9V055GLEqoFaHoC1SoLIaLmWctgCUaBaWxDZ7/Zx4CTyX7cJQLJOok/orfjZAh9kEYpjJa4d0KcJmCbctZA==",
      "license": "MIT"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/pkg-types": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/pkg-types/-/pkg-types-2.3.0.tgz",
      "integrity": "sha512-SIqCzDRg0s9npO5XQ3tNZioRY1uK06lA41ynBC1YmFTmnY6FjUjVt6s4LoADmwoig1qqD0oK8h1p/8mlMx8Oig==",
      "license": "MIT",
      "dependencies": {
        "confbox": "^0.2.2",
        "exsolve": "^1.0.7",
        "pathe": "^2.0.3"
      }
    },
    "node_modules/prisma": {
      "version": "6.16.2",
      "resolved": "https://registry.npmjs.org/prisma/-/prisma-6.16.2.tgz",
      "integrity": "sha512-aRvldGE5UUJTtVmFiH3WfNFNiqFlAtePUxcI0UEGlnXCX7DqhiMT5TRYwncHFeA/Reca5W6ToXXyCMTeFPdSXA==",
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/config": "6.16.2",
        "@prisma/engines": "6.16.2"
      },
      "bin": {
        "prisma": "build/index.js"
      },
      "engines": {
        "node": ">=18.18"
      },
      "peerDependencies": {
        "typescript": ">=5.1.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/process-nextick-args": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/process-nextick-args/-/process-nextick-args-2.0.1.tgz",
      "integrity": "sha512-3ouUOpQhtgrbOa17J7+uxOTpITYWaGP7/AhoR3+A+/1e9skrzelGi/dXzEYyvbxubEF6Wn2ypscTKiKJFFn1ag==",
      "license": "MIT"
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "license": "MIT",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/pstree.remy": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/pstree.remy/-/pstree.remy-1.1.8.tgz",
      "integrity": "sha512-77DZwxQmxKnu3aR542U+X8FypNzbfJ+C5XQDk3uWjWxn6151aIMGthWYRXTqT1E5oJvg+ljaa2OJi+VfvCOQ8w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/pure-rand": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/pure-rand/-/pure-rand-6.1.0.tgz",
      "integrity": "sha512-bVWawvoZoBYpp6yIoQtQXHZjmz35RSVHnUOTefl8Vcjr8snTPY1wnpSPMWekcFwbxI6gtmT7rSYPFvz71ldiOA==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/dubzzz"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/fast-check"
        }
      ],
      "license": "MIT"
    },
    "node_modules/qs": {
      "version": "6.13.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.13.0.tgz",
      "integrity": "sha512-+38qI9SOr8tfZ4QmJNplMUxqjbe7LKvvZgWdExBOmd+egZTtjLB67Gu0HRX3u/XOq7UU2Nx6nsjvS16Z9uwfpg==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.0.6"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "2.5.2",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.5.2.tgz",
      "integrity": "sha512-8zGqypfENjCIqGhgXToC8aB2r7YrBX+AQAfIPs/Mlk+BtPTztOvTS01NRW/3Eh60J+a48lt8qsCzirQ6loCVfA==",
      "license": "MIT",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/raw-body/node_modules/iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/rc9": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/rc9/-/rc9-2.1.2.tgz",
      "integrity": "sha512-btXCnMmRIBINM2LDZoEmOogIZU7Qe7zn4BpomSKZ/ykbLObuBdvG+mFq11DL6fjH1DRwHhrlgtYWG96bJiC7Cg==",
      "license": "MIT",
      "dependencies": {
        "defu": "^6.1.4",
        "destr": "^2.0.3"
      }
    },
    "node_modules/readable-stream": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.8.tgz",
      "integrity": "sha512-8p0AUk4XODgIewSi0l8Epjs+EVnWiK7NoDIEGU0HhE7+ZyY8D1IMY7odu5lRrFXGg71L15KG8QrPmum45RTtdA==",
      "license": "MIT",
      "dependencies": {
        "core-util-is": "~1.0.0",
        "inherits": "~2.0.3",
        "isarray": "~1.0.0",
        "process-nextick-args": "~2.0.0",
        "safe-buffer": "~5.1.1",
        "string_decoder": "~1.1.1",
        "util-deprecate": "~1.0.1"
      }
    },
    "node_modules/readable-stream/node_modules/safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
      "license": "MIT"
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/rimraf": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
      "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
      "deprecated": "Rimraf versions prior to v4 are no longer supported",
      "license": "ISC",
      "dependencies": {
        "glob": "^7.1.3"
      },
      "bin": {
        "rimraf": "bin.js"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/send": {
      "version": "0.19.0",
      "resolved": "https://registry.npmjs.org/send/-/send-0.19.0.tgz",
      "integrity": "sha512-dW41u5VfLXu8SJh5bwRmyYUbAoSB3c9uQh6L8h/KtsFREPWpbX1lrljJo186Jc4nmci/sGUZ9a0a0J2zgfq2hw==",
      "license": "MIT",
      "dependencies": {
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "mime": "1.6.0",
        "ms": "2.1.3",
        "on-finished": "2.4.1",
        "range-parser": "~1.2.1",
        "statuses": "2.0.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/send/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/send/node_modules/debug/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/send/node_modules/encodeurl": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
      "integrity": "sha512-TPJXq8JqFaVYm2CWmPvnP2Iyo4ZSM7/QKcSmuMLDObfpH5fi7RUGmd/rTDf+rut/saiDiQEeVTNgAmJEdAOx0w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/seq-queue": {
      "version": "0.0.5",
      "resolved": "https://registry.npmjs.org/seq-queue/-/seq-queue-0.0.5.tgz",
      "integrity": "sha512-hr3Wtp/GZIc/6DAGPDcV4/9WoZhjrkXsi5B/07QgX8tsdc6ilr7BFM6PM6rbdAX1kFSDYeZGLipIZZKyQP0O5Q=="
    },
    "node_modules/serve-static": {
      "version": "1.16.2",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.16.2.tgz",
      "integrity": "sha512-VqpjJZKadQB/PEbEwvFdO43Ax5dFBZ2UECszz8bQ7pi7wt//PWe1P6MN7eCnjsatYtBT6EuiClbjSWP2WrIoTw==",
      "license": "MIT",
      "dependencies": {
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "parseurl": "~1.3.3",
        "send": "0.19.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/set-blocking": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/set-blocking/-/set-blocking-2.0.0.tgz",
      "integrity": "sha512-KiKBS8AnWGEyLzofFfmvKwpdPzqiy16LvQfK3yv/fVH7Bj13/wl3JSR1J+rfgRE9q7xUJK4qvgS8raSOeLUehw==",
      "license": "ISC"
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
      "license": "ISC"
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/signal-exit": {
      "version": "3.0.7",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
      "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==",
      "license": "ISC"
    },
    "node_modules/simple-update-notifier": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/simple-update-notifier/-/simple-update-notifier-2.0.0.tgz",
      "integrity": "sha512-a2B9Y0KlNXl9u/vsW6sTIu9vGEpfKu2wRV6l1H3XEas/0gUIzGzBoP/IouTcUQbm9JWZLH3COxyn03TYlFax6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^7.5.3"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/sqlstring": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/sqlstring/-/sqlstring-2.3.3.tgz",
      "integrity": "sha512-qC9iz2FlN7DQl3+wjwn3802RTyjCx7sDvfQEXchwa6CWOx07/WVfh91gBmQ9fahw8snwGEWU3xGzOt4tFyHLxg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/statuses": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
      "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/streamsearch": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/streamsearch/-/streamsearch-1.1.0.tgz",
      "integrity": "sha512-Mcc5wHehp9aXz1ax6bZUyY5afg9u2rv5cqQI3mRrYkGC8rW2hM02jWuwjtL++LS5qinSyhj2QfLyNsuc+VsExg==",
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/string_decoder": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz",
      "integrity": "sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.1.0"
      }
    },
    "node_modules/string_decoder/node_modules/safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
      "license": "MIT"
    },
    "node_modules/string-width": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-color": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^3.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/tar": {
      "version": "6.2.1",
      "resolved": "https://registry.npmjs.org/tar/-/tar-6.2.1.tgz",
      "integrity": "sha512-DZ4yORTwrbTj/7MZYq2w+/ZFdI6OZ/f9SFHR+71gIVUZhOQPHzVCLpvRnPgyaMpfWxxk/4ONva3GQSyNIKRv6A==",
      "license": "ISC",
      "dependencies": {
        "chownr": "^2.0.0",
        "fs-minipass": "^2.0.0",
        "minipass": "^5.0.0",
        "minizlib": "^2.1.1",
        "mkdirp": "^1.0.3",
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/tar/node_modules/mkdirp": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
      "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
      "license": "MIT",
      "bin": {
        "mkdirp": "bin/cmd.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/tinyexec": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/tinyexec/-/tinyexec-1.0.1.tgz",
      "integrity": "sha512-5uC6DDlmeqiOwCPmK9jMSdOuZTh8bU39Ys6yidB+UTt5hfZUPGAypSgFRiEp+jbi9qH40BLDvy85jIU88wKSqw==",
      "license": "MIT"
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/touch": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/touch/-/touch-3.1.1.tgz",
      "integrity": "sha512-r0eojU4bI8MnHr8c5bNo7lJDdI2qXlWWJk6a9EAFG7vbhTjElYhBVS3/miuE0uOuoLdb8Mc/rVfsmm6eo5o9GA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "nodetouch": "bin/nodetouch.js"
      }
    },
    "node_modules/tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==",
      "license": "MIT"
    },
    "node_modules/ts-node": {
      "version": "10.9.2",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-10.9.2.tgz",
      "integrity": "sha512-f0FFpIdcHgn8zcPSbf1dRevwt047YMnaiJM3u2w2RewrB+fob/zePZcrOyQoLMMO7aBIddLcQIEK5dYjkLnGrQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@cspotcode/source-map-support": "^0.8.0",
        "@tsconfig/node10": "^1.0.7",
        "@tsconfig/node12": "^1.0.7",
        "@tsconfig/node14": "^1.0.0",
        "@tsconfig/node16": "^1.0.2",
        "acorn": "^8.4.1",
        "acorn-walk": "^8.1.1",
        "arg": "^4.1.0",
        "create-require": "^1.1.0",
        "diff": "^4.0.1",
        "make-error": "^1.1.1",
        "v8-compile-cache-lib": "^3.0.1",
        "yn": "3.1.1"
      },
      "bin": {
        "ts-node": "dist/bin.js",
        "ts-node-cwd": "dist/bin-cwd.js",
        "ts-node-esm": "dist/bin-esm.js",
        "ts-node-script": "dist/bin-script.js",
        "ts-node-transpile-only": "dist/bin-transpile.js",
        "ts-script": "dist/bin-script-deprecated.js"
      },
      "peerDependencies": {
        "@swc/core": ">=1.2.50",
        "@swc/wasm": ">=1.2.50",
        "@types/node": "*",
        "typescript": ">=2.7"
      },
      "peerDependenciesMeta": {
        "@swc/core": {
          "optional": true
        },
        "@swc/wasm": {
          "optional": true
        }
      }
    },
    "node_modules/type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "license": "MIT",
      "dependencies": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/typedarray": {
      "version": "0.0.6",
      "resolved": "https://registry.npmjs.org/typedarray/-/typedarray-0.0.6.tgz",
      "integrity": "sha512-/aCDEGatGvZ2BIk+HmLf4ifCJFwvKFNb9/JeZPMulfgFracn9QFcAf5GO8B/mweUjSoblS5In0cWhqpfs/5PQA==",
      "license": "MIT"
    },
    "node_modules/typescript": {
      "version": "5.9.2",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.2.tgz",
      "integrity": "sha512-CWBzXQrc/qOkhidw1OzBTQuYRbfyxDXJMVJ1XNwUHGROVmuaeiEm3OslpZ1RV96d7SKKjZKrSJu3+t/xlw3R9A==",
      "devOptional": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undefsafe": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/undefsafe/-/undefsafe-2.0.5.tgz",
      "integrity": "sha512-WxONCrssBM8TSPRqN5EmsjVrsv4A8X12J4ArBiiayv3DyyG3ZlIg6yysuuSYdZsVz3TKcTg2fd//Ujd4CHV1iA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "license": "MIT"
    },
    "node_modules/utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/uuid": {
      "version": "8.3.2",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz",
      "integrity": "sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==",
      "license": "MIT",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/v8-compile-cache-lib": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/v8-compile-cache-lib/-/v8-compile-cache-lib-3.0.1.tgz",
      "integrity": "sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==",
      "license": "BSD-2-Clause"
    },
    "node_modules/whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "license": "MIT",
      "dependencies": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    },
    "node_modules/wide-align": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/wide-align/-/wide-align-1.1.5.tgz",
      "integrity": "sha512-eDMORYaPNZ4sQIuuYPDHdQvf4gyCF9rEEV/yPxGfwPkRodwEgiMUUXTx/dex+Me0wxx53S+NgUHaP7y3MGlDmg==",
      "license": "ISC",
      "dependencies": {
        "string-width": "^1.0.2 || 2 || 3 || 4"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "license": "ISC"
    },
    "node_modules/xtend": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/xtend/-/xtend-4.0.2.tgz",
      "integrity": "sha512-LKYU1iAXJXUgAXn9URjiu+MWhyUXHsvfp7mcuYm9dSUKK0/CjtrUwFAxD82/mCWbtLsGjFIad0wIsod4zrTAEQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4"
      }
    },
    "node_modules/yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==",
      "license": "ISC"
    },
    "node_modules/yn": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yn/-/yn-3.1.1.tgz",
      "integrity": "sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    }
  }
}




package.json
{
  "name": "solo-leveling-backend",
  "version": "1.0.0",
  "description": "Backend API for Solo Leveling Life System",
  "main": "dist/app.js",
  "scripts": {
    "dev": "nodemon",
    "build": "tsc",
    "start": "node dist/app.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "@prisma/client": "^6.16.2",
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "dotenv": "^16.6.1",
    "express": "^4.21.2",
    "express-rate-limit": "^6.11.2",
    "helmet": "^7.2.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "mysql2": "^3.14.3",
    "node-cron": "^3.0.3",
    "prisma": "^6.16.2"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/cors": "^2.8.19",
    "@types/express": "^4.17.23",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/multer": "^1.4.13",
    "@types/node": "^20.19.17",
    "nodemon": "^3.1.10",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.2"
  }
}



tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": false,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "noImplicitAny": false,
    "strictNullChecks": false
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}